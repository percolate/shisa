// generated by "charlatan -output=./server_charlatan.go Server".  DO NOT EDIT.

package auxillary

import (
	"reflect"
	"testing"
	"time"
)

// NameInvocation represents a single call of FakeServer.Name
type NameInvocation struct {
	Results struct {
		Ident43 string
	}
}

// AddressInvocation represents a single call of FakeServer.Address
type AddressInvocation struct {
	Results struct {
		Ident44 string
	}
}

// ServeInvocation represents a single call of FakeServer.Serve
type ServeInvocation struct {
	Results struct {
		Ident45 error
	}
}

// ShutdownInvocation represents a single call of FakeServer.Shutdown
type ShutdownInvocation struct {
	Parameters struct {
		Ident46 time.Duration
	}
	Results struct {
		Ident47 error
	}
}

/*
FakeServer is a mock implementation of Server for testing.
Use it in your tests as in this example:

	package example

	func TestWithServer(t *testing.T) {
		f := &auxillary.FakeServer{
			NameHook: func() (ident43 string) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeName ...
		f.AssertNameCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeName.
*/
type FakeServer struct {
	NameHook     func() string
	AddressHook  func() string
	ServeHook    func() error
	ShutdownHook func(time.Duration) error

	NameCalls     []*NameInvocation
	AddressCalls  []*AddressInvocation
	ServeCalls    []*ServeInvocation
	ShutdownCalls []*ShutdownInvocation
}

// NewFakeServerDefaultPanic returns an instance of FakeServer with all hooks configured to panic
func NewFakeServerDefaultPanic() *FakeServer {
	return &FakeServer{
		NameHook: func() (ident43 string) {
			panic("Unexpected call to Server.Name")
		},
		AddressHook: func() (ident44 string) {
			panic("Unexpected call to Server.Address")
		},
		ServeHook: func() (ident45 error) {
			panic("Unexpected call to Server.Serve")
		},
		ShutdownHook: func(time.Duration) (ident47 error) {
			panic("Unexpected call to Server.Shutdown")
		},
	}
}

// NewFakeServerDefaultFatal returns an instance of FakeServer with all hooks configured to call t.Fatal
func NewFakeServerDefaultFatal(t *testing.T) *FakeServer {
	return &FakeServer{
		NameHook: func() (ident43 string) {
			t.Fatal("Unexpected call to Server.Name")
			return
		},
		AddressHook: func() (ident44 string) {
			t.Fatal("Unexpected call to Server.Address")
			return
		},
		ServeHook: func() (ident45 error) {
			t.Fatal("Unexpected call to Server.Serve")
			return
		},
		ShutdownHook: func(time.Duration) (ident47 error) {
			t.Fatal("Unexpected call to Server.Shutdown")
			return
		},
	}
}

// NewFakeServerDefaultError returns an instance of FakeServer with all hooks configured to call t.Error
func NewFakeServerDefaultError(t *testing.T) *FakeServer {
	return &FakeServer{
		NameHook: func() (ident43 string) {
			t.Error("Unexpected call to Server.Name")
			return
		},
		AddressHook: func() (ident44 string) {
			t.Error("Unexpected call to Server.Address")
			return
		},
		ServeHook: func() (ident45 error) {
			t.Error("Unexpected call to Server.Serve")
			return
		},
		ShutdownHook: func(time.Duration) (ident47 error) {
			t.Error("Unexpected call to Server.Shutdown")
			return
		},
	}
}

func (_f1 *FakeServer) Name() (ident43 string) {
	invocation := new(NameInvocation)

	ident43 = _f1.NameHook()

	invocation.Results.Ident43 = ident43

	_f1.NameCalls = append(_f1.NameCalls, invocation)

	return
}

// NameCalled returns true if FakeServer.Name was called
func (f *FakeServer) NameCalled() bool {
	return len(f.NameCalls) != 0
}

// AssertNameCalled calls t.Error if FakeServer.Name was not called
func (f *FakeServer) AssertNameCalled(t *testing.T) {
	t.Helper()
	if len(f.NameCalls) == 0 {
		t.Error("FakeServer.Name not called, expected at least one")
	}
}

// NameNotCalled returns true if FakeServer.Name was not called
func (f *FakeServer) NameNotCalled() bool {
	return len(f.NameCalls) == 0
}

// AssertNameNotCalled calls t.Error if FakeServer.Name was called
func (f *FakeServer) AssertNameNotCalled(t *testing.T) {
	t.Helper()
	if len(f.NameCalls) != 0 {
		t.Error("FakeServer.Name called, expected none")
	}
}

// NameCalledOnce returns true if FakeServer.Name was called exactly once
func (f *FakeServer) NameCalledOnce() bool {
	return len(f.NameCalls) == 1
}

// AssertNameCalledOnce calls t.Error if FakeServer.Name was not called exactly once
func (f *FakeServer) AssertNameCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.NameCalls) != 1 {
		t.Errorf("FakeServer.Name called %d times, expected 1", len(f.NameCalls))
	}
}

// NameCalledN returns true if FakeServer.Name was called at least n times
func (f *FakeServer) NameCalledN(n int) bool {
	return len(f.NameCalls) >= n
}

// AssertNameCalledN calls t.Error if FakeServer.Name was called less than n times
func (f *FakeServer) AssertNameCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.NameCalls) < n {
		t.Errorf("FakeServer.Name called %d times, expected >= %d", len(f.NameCalls), n)
	}
}

func (_f2 *FakeServer) Address() (ident44 string) {
	invocation := new(AddressInvocation)

	ident44 = _f2.AddressHook()

	invocation.Results.Ident44 = ident44

	_f2.AddressCalls = append(_f2.AddressCalls, invocation)

	return
}

// AddressCalled returns true if FakeServer.Address was called
func (f *FakeServer) AddressCalled() bool {
	return len(f.AddressCalls) != 0
}

// AssertAddressCalled calls t.Error if FakeServer.Address was not called
func (f *FakeServer) AssertAddressCalled(t *testing.T) {
	t.Helper()
	if len(f.AddressCalls) == 0 {
		t.Error("FakeServer.Address not called, expected at least one")
	}
}

// AddressNotCalled returns true if FakeServer.Address was not called
func (f *FakeServer) AddressNotCalled() bool {
	return len(f.AddressCalls) == 0
}

// AssertAddressNotCalled calls t.Error if FakeServer.Address was called
func (f *FakeServer) AssertAddressNotCalled(t *testing.T) {
	t.Helper()
	if len(f.AddressCalls) != 0 {
		t.Error("FakeServer.Address called, expected none")
	}
}

// AddressCalledOnce returns true if FakeServer.Address was called exactly once
func (f *FakeServer) AddressCalledOnce() bool {
	return len(f.AddressCalls) == 1
}

// AssertAddressCalledOnce calls t.Error if FakeServer.Address was not called exactly once
func (f *FakeServer) AssertAddressCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.AddressCalls) != 1 {
		t.Errorf("FakeServer.Address called %d times, expected 1", len(f.AddressCalls))
	}
}

// AddressCalledN returns true if FakeServer.Address was called at least n times
func (f *FakeServer) AddressCalledN(n int) bool {
	return len(f.AddressCalls) >= n
}

// AssertAddressCalledN calls t.Error if FakeServer.Address was called less than n times
func (f *FakeServer) AssertAddressCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.AddressCalls) < n {
		t.Errorf("FakeServer.Address called %d times, expected >= %d", len(f.AddressCalls), n)
	}
}

func (_f3 *FakeServer) Serve() (ident45 error) {
	invocation := new(ServeInvocation)

	ident45 = _f3.ServeHook()

	invocation.Results.Ident45 = ident45

	_f3.ServeCalls = append(_f3.ServeCalls, invocation)

	return
}

// ServeCalled returns true if FakeServer.Serve was called
func (f *FakeServer) ServeCalled() bool {
	return len(f.ServeCalls) != 0
}

// AssertServeCalled calls t.Error if FakeServer.Serve was not called
func (f *FakeServer) AssertServeCalled(t *testing.T) {
	t.Helper()
	if len(f.ServeCalls) == 0 {
		t.Error("FakeServer.Serve not called, expected at least one")
	}
}

// ServeNotCalled returns true if FakeServer.Serve was not called
func (f *FakeServer) ServeNotCalled() bool {
	return len(f.ServeCalls) == 0
}

// AssertServeNotCalled calls t.Error if FakeServer.Serve was called
func (f *FakeServer) AssertServeNotCalled(t *testing.T) {
	t.Helper()
	if len(f.ServeCalls) != 0 {
		t.Error("FakeServer.Serve called, expected none")
	}
}

// ServeCalledOnce returns true if FakeServer.Serve was called exactly once
func (f *FakeServer) ServeCalledOnce() bool {
	return len(f.ServeCalls) == 1
}

// AssertServeCalledOnce calls t.Error if FakeServer.Serve was not called exactly once
func (f *FakeServer) AssertServeCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.ServeCalls) != 1 {
		t.Errorf("FakeServer.Serve called %d times, expected 1", len(f.ServeCalls))
	}
}

// ServeCalledN returns true if FakeServer.Serve was called at least n times
func (f *FakeServer) ServeCalledN(n int) bool {
	return len(f.ServeCalls) >= n
}

// AssertServeCalledN calls t.Error if FakeServer.Serve was called less than n times
func (f *FakeServer) AssertServeCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.ServeCalls) < n {
		t.Errorf("FakeServer.Serve called %d times, expected >= %d", len(f.ServeCalls), n)
	}
}

func (_f4 *FakeServer) Shutdown(ident46 time.Duration) (ident47 error) {
	invocation := new(ShutdownInvocation)

	invocation.Parameters.Ident46 = ident46

	ident47 = _f4.ShutdownHook(ident46)

	invocation.Results.Ident47 = ident47

	_f4.ShutdownCalls = append(_f4.ShutdownCalls, invocation)

	return
}

// ShutdownCalled returns true if FakeServer.Shutdown was called
func (f *FakeServer) ShutdownCalled() bool {
	return len(f.ShutdownCalls) != 0
}

// AssertShutdownCalled calls t.Error if FakeServer.Shutdown was not called
func (f *FakeServer) AssertShutdownCalled(t *testing.T) {
	t.Helper()
	if len(f.ShutdownCalls) == 0 {
		t.Error("FakeServer.Shutdown not called, expected at least one")
	}
}

// ShutdownNotCalled returns true if FakeServer.Shutdown was not called
func (f *FakeServer) ShutdownNotCalled() bool {
	return len(f.ShutdownCalls) == 0
}

// AssertShutdownNotCalled calls t.Error if FakeServer.Shutdown was called
func (f *FakeServer) AssertShutdownNotCalled(t *testing.T) {
	t.Helper()
	if len(f.ShutdownCalls) != 0 {
		t.Error("FakeServer.Shutdown called, expected none")
	}
}

// ShutdownCalledOnce returns true if FakeServer.Shutdown was called exactly once
func (f *FakeServer) ShutdownCalledOnce() bool {
	return len(f.ShutdownCalls) == 1
}

// AssertShutdownCalledOnce calls t.Error if FakeServer.Shutdown was not called exactly once
func (f *FakeServer) AssertShutdownCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.ShutdownCalls) != 1 {
		t.Errorf("FakeServer.Shutdown called %d times, expected 1", len(f.ShutdownCalls))
	}
}

// ShutdownCalledN returns true if FakeServer.Shutdown was called at least n times
func (f *FakeServer) ShutdownCalledN(n int) bool {
	return len(f.ShutdownCalls) >= n
}

// AssertShutdownCalledN calls t.Error if FakeServer.Shutdown was called less than n times
func (f *FakeServer) AssertShutdownCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.ShutdownCalls) < n {
		t.Errorf("FakeServer.Shutdown called %d times, expected >= %d", len(f.ShutdownCalls), n)
	}
}

// ShutdownCalledWith returns true if FakeServer.Shutdown was called with the given values
func (_f5 *FakeServer) ShutdownCalledWith(ident46 time.Duration) (found bool) {
	for _, call := range _f5.ShutdownCalls {
		if reflect.DeepEqual(call.Parameters.Ident46, ident46) {
			found = true
			break
		}
	}

	return
}

// AssertShutdownCalledWith calls t.Error if FakeServer.Shutdown was not called with the given values
func (_f6 *FakeServer) AssertShutdownCalledWith(t *testing.T, ident46 time.Duration) {
	t.Helper()
	var found bool
	for _, call := range _f6.ShutdownCalls {
		if reflect.DeepEqual(call.Parameters.Ident46, ident46) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeServer.Shutdown not called with expected parameters")
	}
}

// ShutdownCalledOnceWith returns true if FakeServer.Shutdown was called exactly once with the given values
func (_f7 *FakeServer) ShutdownCalledOnceWith(ident46 time.Duration) bool {
	var count int
	for _, call := range _f7.ShutdownCalls {
		if reflect.DeepEqual(call.Parameters.Ident46, ident46) {
			count++
		}
	}

	return count == 1
}

// AssertShutdownCalledOnceWith calls t.Error if FakeServer.Shutdown was not called exactly once with the given values
func (_f8 *FakeServer) AssertShutdownCalledOnceWith(t *testing.T, ident46 time.Duration) {
	t.Helper()
	var count int
	for _, call := range _f8.ShutdownCalls {
		if reflect.DeepEqual(call.Parameters.Ident46, ident46) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeServer.Shutdown called %d times with expected parameters, expected one", count)
	}
}

// ShutdownResultsForCall returns the result values for the first call to FakeServer.Shutdown with the given values
func (_f9 *FakeServer) ShutdownResultsForCall(ident46 time.Duration) (ident47 error, found bool) {
	for _, call := range _f9.ShutdownCalls {
		if reflect.DeepEqual(call.Parameters.Ident46, ident46) {
			ident47 = call.Results.Ident47
			found = true
			break
		}
	}

	return
}
