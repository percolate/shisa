// generated by "charlatan -output=./handler_charlatan.go Handler".  DO NOT EDIT.

package service

import (
	"reflect"
	"testing"

	"github.com/percolate/shisa/context"
)

// HandleInvocation represents a single call of FakeHandler.Handle
type HandleInvocation struct {
	Parameters struct {
		Ident6 context.Context
		Ident7 *Request
	}
	Results struct {
		Ident8 Response
	}
}

/*
FakeHandler is a mock implementation of Handler for testing.
Use it in your tests as in this example:

	package example

	func TestWithHandler(t *testing.T) {
		f := &service.FakeHandler{
			HandleHook: func(ident6 context.Context, ident7 *Request) (ident8 Response) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeHandle ...
		f.AssertHandleCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeHandle.
*/
type FakeHandler struct {
	HandleHook func(context.Context, *Request) Response

	HandleCalls []*HandleInvocation
}

// NewFakeHandlerDefaultPanic returns an instance of FakeHandler with all hooks configured to panic
func NewFakeHandlerDefaultPanic() *FakeHandler {
	return &FakeHandler{
		HandleHook: func(context.Context, *Request) (ident8 Response) {
			panic("Unexpected call to Handler.Handle")
		},
	}
}

// NewFakeHandlerDefaultFatal returns an instance of FakeHandler with all hooks configured to call t.Fatal
func NewFakeHandlerDefaultFatal(t *testing.T) *FakeHandler {
	return &FakeHandler{
		HandleHook: func(context.Context, *Request) (ident8 Response) {
			t.Fatal("Unexpected call to Handler.Handle")
			return
		},
	}
}

// NewFakeHandlerDefaultError returns an instance of FakeHandler with all hooks configured to call t.Error
func NewFakeHandlerDefaultError(t *testing.T) *FakeHandler {
	return &FakeHandler{
		HandleHook: func(context.Context, *Request) (ident8 Response) {
			t.Error("Unexpected call to Handler.Handle")
			return
		},
	}
}

func (_f1 *FakeHandler) Handle(ident6 context.Context, ident7 *Request) (ident8 Response) {
	invocation := new(HandleInvocation)

	invocation.Parameters.Ident6 = ident6
	invocation.Parameters.Ident7 = ident7

	ident8 = _f1.HandleHook(ident6, ident7)

	invocation.Results.Ident8 = ident8

	_f1.HandleCalls = append(_f1.HandleCalls, invocation)

	return
}

// HandleCalled returns true if FakeHandler.Handle was called
func (f *FakeHandler) HandleCalled() bool {
	return len(f.HandleCalls) != 0
}

// AssertHandleCalled calls t.Error if FakeHandler.Handle was not called
func (f *FakeHandler) AssertHandleCalled(t *testing.T) {
	t.Helper()
	if len(f.HandleCalls) == 0 {
		t.Error("FakeHandler.Handle not called, expected at least one")
	}
}

// HandleNotCalled returns true if FakeHandler.Handle was not called
func (f *FakeHandler) HandleNotCalled() bool {
	return len(f.HandleCalls) == 0
}

// AssertHandleNotCalled calls t.Error if FakeHandler.Handle was called
func (f *FakeHandler) AssertHandleNotCalled(t *testing.T) {
	t.Helper()
	if len(f.HandleCalls) != 0 {
		t.Error("FakeHandler.Handle called, expected none")
	}
}

// HandleCalledOnce returns true if FakeHandler.Handle was called exactly once
func (f *FakeHandler) HandleCalledOnce() bool {
	return len(f.HandleCalls) == 1
}

// AssertHandleCalledOnce calls t.Error if FakeHandler.Handle was not called exactly once
func (f *FakeHandler) AssertHandleCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.HandleCalls) != 1 {
		t.Errorf("FakeHandler.Handle called %d times, expected 1", len(f.HandleCalls))
	}
}

// HandleCalledN returns true if FakeHandler.Handle was called at least n times
func (f *FakeHandler) HandleCalledN(n int) bool {
	return len(f.HandleCalls) >= n
}

// AssertHandleCalledN calls t.Error if FakeHandler.Handle was called less than n times
func (f *FakeHandler) AssertHandleCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.HandleCalls) < n {
		t.Errorf("FakeHandler.Handle called %d times, expected >= %d", len(f.HandleCalls), n)
	}
}

// HandleCalledWith returns true if FakeHandler.Handle was called with the given values
func (_f2 *FakeHandler) HandleCalledWith(ident6 context.Context, ident7 *Request) (found bool) {
	for _, call := range _f2.HandleCalls {
		if reflect.DeepEqual(call.Parameters.Ident6, ident6) && reflect.DeepEqual(call.Parameters.Ident7, ident7) {
			found = true
			break
		}
	}

	return
}

// AssertHandleCalledWith calls t.Error if FakeHandler.Handle was not called with the given values
func (_f3 *FakeHandler) AssertHandleCalledWith(t *testing.T, ident6 context.Context, ident7 *Request) {
	t.Helper()
	var found bool
	for _, call := range _f3.HandleCalls {
		if reflect.DeepEqual(call.Parameters.Ident6, ident6) && reflect.DeepEqual(call.Parameters.Ident7, ident7) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeHandler.Handle not called with expected parameters")
	}
}

// HandleCalledOnceWith returns true if FakeHandler.Handle was called exactly once with the given values
func (_f4 *FakeHandler) HandleCalledOnceWith(ident6 context.Context, ident7 *Request) bool {
	var count int
	for _, call := range _f4.HandleCalls {
		if reflect.DeepEqual(call.Parameters.Ident6, ident6) && reflect.DeepEqual(call.Parameters.Ident7, ident7) {
			count++
		}
	}

	return count == 1
}

// AssertHandleCalledOnceWith calls t.Error if FakeHandler.Handle was not called exactly once with the given values
func (_f5 *FakeHandler) AssertHandleCalledOnceWith(t *testing.T, ident6 context.Context, ident7 *Request) {
	t.Helper()
	var count int
	for _, call := range _f5.HandleCalls {
		if reflect.DeepEqual(call.Parameters.Ident6, ident6) && reflect.DeepEqual(call.Parameters.Ident7, ident7) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeHandler.Handle called %d times with expected parameters, expected one", count)
	}
}

// HandleResultsForCall returns the result values for the first call to FakeHandler.Handle with the given values
func (_f6 *FakeHandler) HandleResultsForCall(ident6 context.Context, ident7 *Request) (ident8 Response, found bool) {
	for _, call := range _f6.HandleCalls {
		if reflect.DeepEqual(call.Parameters.Ident6, ident6) && reflect.DeepEqual(call.Parameters.Ident7, ident7) {
			ident8 = call.Results.Ident8
			found = true
			break
		}
	}

	return
}
