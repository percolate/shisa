// generated by "charlatan -output=./registrar_charlatan.go Registrar".  DO NOT EDIT.

package sd

import "net/url"
import "github.com/ansel1/merry"

import "reflect"

// RegistrarRegisterInvocation represents a single call of FakeRegistrar.Register
type RegistrarRegisterInvocation struct {
	Parameters struct {
		ServiceID string
		Addr      string
	}
	Results struct {
		Ident1 merry.Error
	}
}

// RegistrarDeregisterInvocation represents a single call of FakeRegistrar.Deregister
type RegistrarDeregisterInvocation struct {
	Parameters struct {
		ServiceID string
	}
	Results struct {
		Ident1 merry.Error
	}
}

// RegistrarAddCheckInvocation represents a single call of FakeRegistrar.AddCheck
type RegistrarAddCheckInvocation struct {
	Parameters struct {
		Service string
		Url     *url.URL
	}
	Results struct {
		Ident1 merry.Error
	}
}

// RegistrarRemoveChecksInvocation represents a single call of FakeRegistrar.RemoveChecks
type RegistrarRemoveChecksInvocation struct {
	Parameters struct {
		Service string
	}
	Results struct {
		Ident1 merry.Error
	}
}

// RegistrarTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type RegistrarTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeRegistrar is a mock implementation of Registrar for testing.
Use it in your tests as in this example:

	package example

	func TestWithRegistrar(t *testing.T) {
		f := &sd.FakeRegistrar{
			RegisterHook: func(serviceID string, addr string) (ident1 merry.Error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeRegister ...
		f.AssertRegisterCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeRegister.
*/
type FakeRegistrar struct {
	RegisterHook     func(string, string) merry.Error
	DeregisterHook   func(string) merry.Error
	AddCheckHook     func(string, *url.URL) merry.Error
	RemoveChecksHook func(string) merry.Error

	RegisterCalls     []*RegistrarRegisterInvocation
	DeregisterCalls   []*RegistrarDeregisterInvocation
	AddCheckCalls     []*RegistrarAddCheckInvocation
	RemoveChecksCalls []*RegistrarRemoveChecksInvocation
}

// NewFakeRegistrarDefaultPanic returns an instance of FakeRegistrar with all hooks configured to panic
func NewFakeRegistrarDefaultPanic() *FakeRegistrar {
	return &FakeRegistrar{
		RegisterHook: func(string, string) (ident1 merry.Error) {
			panic("Unexpected call to Registrar.Register")
		},
		DeregisterHook: func(string) (ident1 merry.Error) {
			panic("Unexpected call to Registrar.Deregister")
		},
		AddCheckHook: func(string, *url.URL) (ident1 merry.Error) {
			panic("Unexpected call to Registrar.AddCheck")
		},
		RemoveChecksHook: func(string) (ident1 merry.Error) {
			panic("Unexpected call to Registrar.RemoveChecks")
		},
	}
}

// NewFakeRegistrarDefaultFatal returns an instance of FakeRegistrar with all hooks configured to call t.Fatal
func NewFakeRegistrarDefaultFatal(t RegistrarTestingT) *FakeRegistrar {
	return &FakeRegistrar{
		RegisterHook: func(string, string) (ident1 merry.Error) {
			t.Fatal("Unexpected call to Registrar.Register")
			return
		},
		DeregisterHook: func(string) (ident1 merry.Error) {
			t.Fatal("Unexpected call to Registrar.Deregister")
			return
		},
		AddCheckHook: func(string, *url.URL) (ident1 merry.Error) {
			t.Fatal("Unexpected call to Registrar.AddCheck")
			return
		},
		RemoveChecksHook: func(string) (ident1 merry.Error) {
			t.Fatal("Unexpected call to Registrar.RemoveChecks")
			return
		},
	}
}

// NewFakeRegistrarDefaultError returns an instance of FakeRegistrar with all hooks configured to call t.Error
func NewFakeRegistrarDefaultError(t RegistrarTestingT) *FakeRegistrar {
	return &FakeRegistrar{
		RegisterHook: func(string, string) (ident1 merry.Error) {
			t.Error("Unexpected call to Registrar.Register")
			return
		},
		DeregisterHook: func(string) (ident1 merry.Error) {
			t.Error("Unexpected call to Registrar.Deregister")
			return
		},
		AddCheckHook: func(string, *url.URL) (ident1 merry.Error) {
			t.Error("Unexpected call to Registrar.AddCheck")
			return
		},
		RemoveChecksHook: func(string) (ident1 merry.Error) {
			t.Error("Unexpected call to Registrar.RemoveChecks")
			return
		},
	}
}

func (f *FakeRegistrar) Reset() {
	f.RegisterCalls = []*RegistrarRegisterInvocation{}
	f.DeregisterCalls = []*RegistrarDeregisterInvocation{}
	f.AddCheckCalls = []*RegistrarAddCheckInvocation{}
	f.RemoveChecksCalls = []*RegistrarRemoveChecksInvocation{}
}

func (_f1 *FakeRegistrar) Register(serviceID string, addr string) (ident1 merry.Error) {
	invocation := new(RegistrarRegisterInvocation)

	invocation.Parameters.ServiceID = serviceID
	invocation.Parameters.Addr = addr

	ident1 = _f1.RegisterHook(serviceID, addr)

	invocation.Results.Ident1 = ident1

	_f1.RegisterCalls = append(_f1.RegisterCalls, invocation)

	return
}

// RegisterCalled returns true if FakeRegistrar.Register was called
func (f *FakeRegistrar) RegisterCalled() bool {
	return len(f.RegisterCalls) != 0
}

// AssertRegisterCalled calls t.Error if FakeRegistrar.Register was not called
func (f *FakeRegistrar) AssertRegisterCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.RegisterCalls) == 0 {
		t.Error("FakeRegistrar.Register not called, expected at least one")
	}
}

// RegisterNotCalled returns true if FakeRegistrar.Register was not called
func (f *FakeRegistrar) RegisterNotCalled() bool {
	return len(f.RegisterCalls) == 0
}

// AssertRegisterNotCalled calls t.Error if FakeRegistrar.Register was called
func (f *FakeRegistrar) AssertRegisterNotCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.RegisterCalls) != 0 {
		t.Error("FakeRegistrar.Register called, expected none")
	}
}

// RegisterCalledOnce returns true if FakeRegistrar.Register was called exactly once
func (f *FakeRegistrar) RegisterCalledOnce() bool {
	return len(f.RegisterCalls) == 1
}

// AssertRegisterCalledOnce calls t.Error if FakeRegistrar.Register was not called exactly once
func (f *FakeRegistrar) AssertRegisterCalledOnce(t RegistrarTestingT) {
	t.Helper()
	if len(f.RegisterCalls) != 1 {
		t.Errorf("FakeRegistrar.Register called %d times, expected 1", len(f.RegisterCalls))
	}
}

// RegisterCalledN returns true if FakeRegistrar.Register was called at least n times
func (f *FakeRegistrar) RegisterCalledN(n int) bool {
	return len(f.RegisterCalls) >= n
}

// AssertRegisterCalledN calls t.Error if FakeRegistrar.Register was called less than n times
func (f *FakeRegistrar) AssertRegisterCalledN(t RegistrarTestingT, n int) {
	t.Helper()
	if len(f.RegisterCalls) < n {
		t.Errorf("FakeRegistrar.Register called %d times, expected >= %d", len(f.RegisterCalls), n)
	}
}

// RegisterCalledWith returns true if FakeRegistrar.Register was called with the given values
func (_f2 *FakeRegistrar) RegisterCalledWith(serviceID string, addr string) (found bool) {
	for _, call := range _f2.RegisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) && reflect.DeepEqual(call.Parameters.Addr, addr) {
			found = true
			break
		}
	}

	return
}

// AssertRegisterCalledWith calls t.Error if FakeRegistrar.Register was not called with the given values
func (_f3 *FakeRegistrar) AssertRegisterCalledWith(t RegistrarTestingT, serviceID string, addr string) {
	t.Helper()
	var found bool
	for _, call := range _f3.RegisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) && reflect.DeepEqual(call.Parameters.Addr, addr) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeRegistrar.Register not called with expected parameters")
	}
}

// RegisterCalledOnceWith returns true if FakeRegistrar.Register was called exactly once with the given values
func (_f4 *FakeRegistrar) RegisterCalledOnceWith(serviceID string, addr string) bool {
	var count int
	for _, call := range _f4.RegisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) && reflect.DeepEqual(call.Parameters.Addr, addr) {
			count++
		}
	}

	return count == 1
}

// AssertRegisterCalledOnceWith calls t.Error if FakeRegistrar.Register was not called exactly once with the given values
func (_f5 *FakeRegistrar) AssertRegisterCalledOnceWith(t RegistrarTestingT, serviceID string, addr string) {
	t.Helper()
	var count int
	for _, call := range _f5.RegisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) && reflect.DeepEqual(call.Parameters.Addr, addr) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeRegistrar.Register called %d times with expected parameters, expected one", count)
	}
}

// RegisterResultsForCall returns the result values for the first call to FakeRegistrar.Register with the given values
func (_f6 *FakeRegistrar) RegisterResultsForCall(serviceID string, addr string) (ident1 merry.Error, found bool) {
	for _, call := range _f6.RegisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) && reflect.DeepEqual(call.Parameters.Addr, addr) {
			ident1 = call.Results.Ident1
			found = true
			break
		}
	}

	return
}

func (_f7 *FakeRegistrar) Deregister(serviceID string) (ident1 merry.Error) {
	invocation := new(RegistrarDeregisterInvocation)

	invocation.Parameters.ServiceID = serviceID

	ident1 = _f7.DeregisterHook(serviceID)

	invocation.Results.Ident1 = ident1

	_f7.DeregisterCalls = append(_f7.DeregisterCalls, invocation)

	return
}

// DeregisterCalled returns true if FakeRegistrar.Deregister was called
func (f *FakeRegistrar) DeregisterCalled() bool {
	return len(f.DeregisterCalls) != 0
}

// AssertDeregisterCalled calls t.Error if FakeRegistrar.Deregister was not called
func (f *FakeRegistrar) AssertDeregisterCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.DeregisterCalls) == 0 {
		t.Error("FakeRegistrar.Deregister not called, expected at least one")
	}
}

// DeregisterNotCalled returns true if FakeRegistrar.Deregister was not called
func (f *FakeRegistrar) DeregisterNotCalled() bool {
	return len(f.DeregisterCalls) == 0
}

// AssertDeregisterNotCalled calls t.Error if FakeRegistrar.Deregister was called
func (f *FakeRegistrar) AssertDeregisterNotCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.DeregisterCalls) != 0 {
		t.Error("FakeRegistrar.Deregister called, expected none")
	}
}

// DeregisterCalledOnce returns true if FakeRegistrar.Deregister was called exactly once
func (f *FakeRegistrar) DeregisterCalledOnce() bool {
	return len(f.DeregisterCalls) == 1
}

// AssertDeregisterCalledOnce calls t.Error if FakeRegistrar.Deregister was not called exactly once
func (f *FakeRegistrar) AssertDeregisterCalledOnce(t RegistrarTestingT) {
	t.Helper()
	if len(f.DeregisterCalls) != 1 {
		t.Errorf("FakeRegistrar.Deregister called %d times, expected 1", len(f.DeregisterCalls))
	}
}

// DeregisterCalledN returns true if FakeRegistrar.Deregister was called at least n times
func (f *FakeRegistrar) DeregisterCalledN(n int) bool {
	return len(f.DeregisterCalls) >= n
}

// AssertDeregisterCalledN calls t.Error if FakeRegistrar.Deregister was called less than n times
func (f *FakeRegistrar) AssertDeregisterCalledN(t RegistrarTestingT, n int) {
	t.Helper()
	if len(f.DeregisterCalls) < n {
		t.Errorf("FakeRegistrar.Deregister called %d times, expected >= %d", len(f.DeregisterCalls), n)
	}
}

// DeregisterCalledWith returns true if FakeRegistrar.Deregister was called with the given values
func (_f8 *FakeRegistrar) DeregisterCalledWith(serviceID string) (found bool) {
	for _, call := range _f8.DeregisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) {
			found = true
			break
		}
	}

	return
}

// AssertDeregisterCalledWith calls t.Error if FakeRegistrar.Deregister was not called with the given values
func (_f9 *FakeRegistrar) AssertDeregisterCalledWith(t RegistrarTestingT, serviceID string) {
	t.Helper()
	var found bool
	for _, call := range _f9.DeregisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeRegistrar.Deregister not called with expected parameters")
	}
}

// DeregisterCalledOnceWith returns true if FakeRegistrar.Deregister was called exactly once with the given values
func (_f10 *FakeRegistrar) DeregisterCalledOnceWith(serviceID string) bool {
	var count int
	for _, call := range _f10.DeregisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) {
			count++
		}
	}

	return count == 1
}

// AssertDeregisterCalledOnceWith calls t.Error if FakeRegistrar.Deregister was not called exactly once with the given values
func (_f11 *FakeRegistrar) AssertDeregisterCalledOnceWith(t RegistrarTestingT, serviceID string) {
	t.Helper()
	var count int
	for _, call := range _f11.DeregisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeRegistrar.Deregister called %d times with expected parameters, expected one", count)
	}
}

// DeregisterResultsForCall returns the result values for the first call to FakeRegistrar.Deregister with the given values
func (_f12 *FakeRegistrar) DeregisterResultsForCall(serviceID string) (ident1 merry.Error, found bool) {
	for _, call := range _f12.DeregisterCalls {
		if reflect.DeepEqual(call.Parameters.ServiceID, serviceID) {
			ident1 = call.Results.Ident1
			found = true
			break
		}
	}

	return
}

func (_f13 *FakeRegistrar) AddCheck(service string, url *url.URL) (ident1 merry.Error) {
	invocation := new(RegistrarAddCheckInvocation)

	invocation.Parameters.Service = service
	invocation.Parameters.Url = url

	ident1 = _f13.AddCheckHook(service, url)

	invocation.Results.Ident1 = ident1

	_f13.AddCheckCalls = append(_f13.AddCheckCalls, invocation)

	return
}

// AddCheckCalled returns true if FakeRegistrar.AddCheck was called
func (f *FakeRegistrar) AddCheckCalled() bool {
	return len(f.AddCheckCalls) != 0
}

// AssertAddCheckCalled calls t.Error if FakeRegistrar.AddCheck was not called
func (f *FakeRegistrar) AssertAddCheckCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.AddCheckCalls) == 0 {
		t.Error("FakeRegistrar.AddCheck not called, expected at least one")
	}
}

// AddCheckNotCalled returns true if FakeRegistrar.AddCheck was not called
func (f *FakeRegistrar) AddCheckNotCalled() bool {
	return len(f.AddCheckCalls) == 0
}

// AssertAddCheckNotCalled calls t.Error if FakeRegistrar.AddCheck was called
func (f *FakeRegistrar) AssertAddCheckNotCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.AddCheckCalls) != 0 {
		t.Error("FakeRegistrar.AddCheck called, expected none")
	}
}

// AddCheckCalledOnce returns true if FakeRegistrar.AddCheck was called exactly once
func (f *FakeRegistrar) AddCheckCalledOnce() bool {
	return len(f.AddCheckCalls) == 1
}

// AssertAddCheckCalledOnce calls t.Error if FakeRegistrar.AddCheck was not called exactly once
func (f *FakeRegistrar) AssertAddCheckCalledOnce(t RegistrarTestingT) {
	t.Helper()
	if len(f.AddCheckCalls) != 1 {
		t.Errorf("FakeRegistrar.AddCheck called %d times, expected 1", len(f.AddCheckCalls))
	}
}

// AddCheckCalledN returns true if FakeRegistrar.AddCheck was called at least n times
func (f *FakeRegistrar) AddCheckCalledN(n int) bool {
	return len(f.AddCheckCalls) >= n
}

// AssertAddCheckCalledN calls t.Error if FakeRegistrar.AddCheck was called less than n times
func (f *FakeRegistrar) AssertAddCheckCalledN(t RegistrarTestingT, n int) {
	t.Helper()
	if len(f.AddCheckCalls) < n {
		t.Errorf("FakeRegistrar.AddCheck called %d times, expected >= %d", len(f.AddCheckCalls), n)
	}
}

// AddCheckCalledWith returns true if FakeRegistrar.AddCheck was called with the given values
func (_f14 *FakeRegistrar) AddCheckCalledWith(service string, url *url.URL) (found bool) {
	for _, call := range _f14.AddCheckCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) && reflect.DeepEqual(call.Parameters.Url, url) {
			found = true
			break
		}
	}

	return
}

// AssertAddCheckCalledWith calls t.Error if FakeRegistrar.AddCheck was not called with the given values
func (_f15 *FakeRegistrar) AssertAddCheckCalledWith(t RegistrarTestingT, service string, url *url.URL) {
	t.Helper()
	var found bool
	for _, call := range _f15.AddCheckCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) && reflect.DeepEqual(call.Parameters.Url, url) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeRegistrar.AddCheck not called with expected parameters")
	}
}

// AddCheckCalledOnceWith returns true if FakeRegistrar.AddCheck was called exactly once with the given values
func (_f16 *FakeRegistrar) AddCheckCalledOnceWith(service string, url *url.URL) bool {
	var count int
	for _, call := range _f16.AddCheckCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) && reflect.DeepEqual(call.Parameters.Url, url) {
			count++
		}
	}

	return count == 1
}

// AssertAddCheckCalledOnceWith calls t.Error if FakeRegistrar.AddCheck was not called exactly once with the given values
func (_f17 *FakeRegistrar) AssertAddCheckCalledOnceWith(t RegistrarTestingT, service string, url *url.URL) {
	t.Helper()
	var count int
	for _, call := range _f17.AddCheckCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) && reflect.DeepEqual(call.Parameters.Url, url) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeRegistrar.AddCheck called %d times with expected parameters, expected one", count)
	}
}

// AddCheckResultsForCall returns the result values for the first call to FakeRegistrar.AddCheck with the given values
func (_f18 *FakeRegistrar) AddCheckResultsForCall(service string, url *url.URL) (ident1 merry.Error, found bool) {
	for _, call := range _f18.AddCheckCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) && reflect.DeepEqual(call.Parameters.Url, url) {
			ident1 = call.Results.Ident1
			found = true
			break
		}
	}

	return
}

func (_f19 *FakeRegistrar) RemoveChecks(service string) (ident1 merry.Error) {
	invocation := new(RegistrarRemoveChecksInvocation)

	invocation.Parameters.Service = service

	ident1 = _f19.RemoveChecksHook(service)

	invocation.Results.Ident1 = ident1

	_f19.RemoveChecksCalls = append(_f19.RemoveChecksCalls, invocation)

	return
}

// RemoveChecksCalled returns true if FakeRegistrar.RemoveChecks was called
func (f *FakeRegistrar) RemoveChecksCalled() bool {
	return len(f.RemoveChecksCalls) != 0
}

// AssertRemoveChecksCalled calls t.Error if FakeRegistrar.RemoveChecks was not called
func (f *FakeRegistrar) AssertRemoveChecksCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.RemoveChecksCalls) == 0 {
		t.Error("FakeRegistrar.RemoveChecks not called, expected at least one")
	}
}

// RemoveChecksNotCalled returns true if FakeRegistrar.RemoveChecks was not called
func (f *FakeRegistrar) RemoveChecksNotCalled() bool {
	return len(f.RemoveChecksCalls) == 0
}

// AssertRemoveChecksNotCalled calls t.Error if FakeRegistrar.RemoveChecks was called
func (f *FakeRegistrar) AssertRemoveChecksNotCalled(t RegistrarTestingT) {
	t.Helper()
	if len(f.RemoveChecksCalls) != 0 {
		t.Error("FakeRegistrar.RemoveChecks called, expected none")
	}
}

// RemoveChecksCalledOnce returns true if FakeRegistrar.RemoveChecks was called exactly once
func (f *FakeRegistrar) RemoveChecksCalledOnce() bool {
	return len(f.RemoveChecksCalls) == 1
}

// AssertRemoveChecksCalledOnce calls t.Error if FakeRegistrar.RemoveChecks was not called exactly once
func (f *FakeRegistrar) AssertRemoveChecksCalledOnce(t RegistrarTestingT) {
	t.Helper()
	if len(f.RemoveChecksCalls) != 1 {
		t.Errorf("FakeRegistrar.RemoveChecks called %d times, expected 1", len(f.RemoveChecksCalls))
	}
}

// RemoveChecksCalledN returns true if FakeRegistrar.RemoveChecks was called at least n times
func (f *FakeRegistrar) RemoveChecksCalledN(n int) bool {
	return len(f.RemoveChecksCalls) >= n
}

// AssertRemoveChecksCalledN calls t.Error if FakeRegistrar.RemoveChecks was called less than n times
func (f *FakeRegistrar) AssertRemoveChecksCalledN(t RegistrarTestingT, n int) {
	t.Helper()
	if len(f.RemoveChecksCalls) < n {
		t.Errorf("FakeRegistrar.RemoveChecks called %d times, expected >= %d", len(f.RemoveChecksCalls), n)
	}
}

// RemoveChecksCalledWith returns true if FakeRegistrar.RemoveChecks was called with the given values
func (_f20 *FakeRegistrar) RemoveChecksCalledWith(service string) (found bool) {
	for _, call := range _f20.RemoveChecksCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) {
			found = true
			break
		}
	}

	return
}

// AssertRemoveChecksCalledWith calls t.Error if FakeRegistrar.RemoveChecks was not called with the given values
func (_f21 *FakeRegistrar) AssertRemoveChecksCalledWith(t RegistrarTestingT, service string) {
	t.Helper()
	var found bool
	for _, call := range _f21.RemoveChecksCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeRegistrar.RemoveChecks not called with expected parameters")
	}
}

// RemoveChecksCalledOnceWith returns true if FakeRegistrar.RemoveChecks was called exactly once with the given values
func (_f22 *FakeRegistrar) RemoveChecksCalledOnceWith(service string) bool {
	var count int
	for _, call := range _f22.RemoveChecksCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) {
			count++
		}
	}

	return count == 1
}

// AssertRemoveChecksCalledOnceWith calls t.Error if FakeRegistrar.RemoveChecks was not called exactly once with the given values
func (_f23 *FakeRegistrar) AssertRemoveChecksCalledOnceWith(t RegistrarTestingT, service string) {
	t.Helper()
	var count int
	for _, call := range _f23.RemoveChecksCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeRegistrar.RemoveChecks called %d times with expected parameters, expected one", count)
	}
}

// RemoveChecksResultsForCall returns the result values for the first call to FakeRegistrar.RemoveChecks with the given values
func (_f24 *FakeRegistrar) RemoveChecksResultsForCall(service string) (ident1 merry.Error, found bool) {
	for _, call := range _f24.RemoveChecksCalls {
		if reflect.DeepEqual(call.Parameters.Service, service) {
			ident1 = call.Results.Ident1
			found = true
			break
		}
	}

	return
}
