// Code generated by "charlatan -interfaces=Logger -output=./logtest/charlatanlogger.go"; DO NOT EDIT.

package logtest

///////////////////////////////
// This is a mock for Logger //
///////////////////////////////
type InfoInvocation struct {
	Parameters struct {
		RequestID string
		Message   string
	}
}

type InfofInvocation struct {
	Parameters struct {
		RequestID string
		Format    string
		Args      []interface{}
	}
}

type ErrorInvocation struct {
	Parameters struct {
		RequestID string
		Message   string
	}
}

type ErrorfInvocation struct {
	Parameters struct {
		RequestID string
		Format    string
		Args      []interface{}
	}
}

type TraceInvocation struct {
	Parameters struct {
		RequestID string
		Message   string
	}
}

type TracefInvocation struct {
	Parameters struct {
		RequestID string
		Format    string
		Args      []interface{}
	}
}

type CloseInvocation struct {
}

type FakeLogger struct {
	InfoHook   func(requestID string, message string)
	InfofHook  func(requestID string, format string, args ...interface{})
	ErrorHook  func(requestID string, message string)
	ErrorfHook func(requestID string, format string, args ...interface{})
	TraceHook  func(requestID string, message string)
	TracefHook func(requestID string, format string, args ...interface{})
	CloseHook  func()

	InfoCalls   []*InfoInvocation
	InfofCalls  []*InfofInvocation
	ErrorCalls  []*ErrorInvocation
	ErrorfCalls []*ErrorfInvocation
	TraceCalls  []*TraceInvocation
	TracefCalls []*TracefInvocation
	CloseCalls  []*CloseInvocation
}

func (a *FakeLogger) Info(requestID string, message string) {
	invocation := new(InfoInvocation)

	invocation.Parameters.RequestID = requestID
	invocation.Parameters.Message = message

	a.InfoHook(requestID, message)

	a.InfoCalls = append(a.InfoCalls, invocation)

	return
}

func (a *FakeLogger) Infof(requestID string, format string, args ...interface{}) {
	invocation := new(InfofInvocation)

	invocation.Parameters.RequestID = requestID
	invocation.Parameters.Format = format
	invocation.Parameters.Args = args

	a.InfofHook(requestID, format, args...)

	a.InfofCalls = append(a.InfofCalls, invocation)

	return
}

func (a *FakeLogger) Error(requestID string, message string) {
	invocation := new(ErrorInvocation)

	invocation.Parameters.RequestID = requestID
	invocation.Parameters.Message = message

	a.ErrorHook(requestID, message)

	a.ErrorCalls = append(a.ErrorCalls, invocation)

	return
}

func (a *FakeLogger) Errorf(requestID string, format string, args ...interface{}) {
	invocation := new(ErrorfInvocation)

	invocation.Parameters.RequestID = requestID
	invocation.Parameters.Format = format
	invocation.Parameters.Args = args

	a.ErrorfHook(requestID, format, args...)

	a.ErrorfCalls = append(a.ErrorfCalls, invocation)

	return
}

func (a *FakeLogger) Trace(requestID string, message string) {
	invocation := new(TraceInvocation)

	invocation.Parameters.RequestID = requestID
	invocation.Parameters.Message = message

	a.TraceHook(requestID, message)

	a.TraceCalls = append(a.TraceCalls, invocation)

	return
}

func (a *FakeLogger) Tracef(requestID string, format string, args ...interface{}) {
	invocation := new(TracefInvocation)

	invocation.Parameters.RequestID = requestID
	invocation.Parameters.Format = format
	invocation.Parameters.Args = args

	a.TracefHook(requestID, format, args...)

	a.TracefCalls = append(a.TracefCalls, invocation)

	return
}

func (a *FakeLogger) Close() {
	invocation := new(CloseInvocation)

	a.CloseHook()

	a.CloseCalls = append(a.CloseCalls, invocation)

	return
}
