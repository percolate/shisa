// generated by "charlatan -file=/usr/local/go/src/context/context.go -output=./contexttest/charlatancontext.go -package=contexttest Context".  DO NOT EDIT.

package contexttest

import (
	"reflect"
	"testing"
	"time"
)

// DeadlineInvocation represents a single call of FakeContext.Deadline
type DeadlineInvocation struct {
	Results struct {
		Deadline time.Time
		Ok       bool
	}
}

// DoneInvocation represents a single call of FakeContext.Done
type DoneInvocation struct {
	Results struct {
		Ident1 <-chan struct{}
	}
}

// ErrInvocation represents a single call of FakeContext.Err
type ErrInvocation struct {
	Results struct {
		Ident2 error
	}
}

// ValueInvocation represents a single call of FakeContext.Value
type ValueInvocation struct {
	Parameters struct {
		Key interface{}
	}
	Results struct {
		Ident3 interface{}
	}
}

/*
FakeContext is a mock implementation of Context for testing.
Use it in your tests as in this example:

	package example

	func TestWithContext(t *testing.T) {
		f := &contexttest.FakeContext{
			DeadlineHook: func() (deadline time.Time, ok bool) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeDeadline ...
		f.AssertDeadlineCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a painc if any
unexpected calls are made to FakeDeadline.
*/
type FakeContext struct {
	DeadlineHook func() (time.Time, bool)
	DoneHook     func() <-chan struct{}
	ErrHook      func() error
	ValueHook    func(interface{}) interface{}

	DeadlineCalls []*DeadlineInvocation
	DoneCalls     []*DoneInvocation
	ErrCalls      []*ErrInvocation
	ValueCalls    []*ValueInvocation
}

// NewFakeContextDefaultPanic returns an instance of FakeContext with all hooks configured to panic
func NewFakeContextDefaultPanic() *FakeContext {
	return &FakeContext{
		DeadlineHook: func() (deadline time.Time, ok bool) {
			panic("Unexpected call to Context.Deadline")
			return
		},
		DoneHook: func() (ident1 <-chan struct{}) {
			panic("Unexpected call to Context.Done")
			return
		},
		ErrHook: func() (ident2 error) {
			panic("Unexpected call to Context.Err")
			return
		},
		ValueHook: func(interface{}) (ident3 interface{}) {
			panic("Unexpected call to Context.Value")
			return
		},
	}
}

// NewFakeContextDefaultFatal returns an instance of FakeContext with all hooks configured to call t.Fatal
func NewFakeContextDefaultFatal(t *testing.T) *FakeContext {
	return &FakeContext{
		DeadlineHook: func() (deadline time.Time, ok bool) {
			t.Fatal("Unexpected call to Context.Deadline")
			return
		},
		DoneHook: func() (ident1 <-chan struct{}) {
			t.Fatal("Unexpected call to Context.Done")
			return
		},
		ErrHook: func() (ident2 error) {
			t.Fatal("Unexpected call to Context.Err")
			return
		},
		ValueHook: func(interface{}) (ident3 interface{}) {
			t.Fatal("Unexpected call to Context.Value")
			return
		},
	}
}

// NewFakeContextDefaultError returns an instance of FakeContext with all hooks configured to call t.Error
func NewFakeContextDefaultError(t *testing.T) *FakeContext {
	return &FakeContext{
		DeadlineHook: func() (deadline time.Time, ok bool) {
			t.Error("Unexpected call to Context.Deadline")
			return
		},
		DoneHook: func() (ident1 <-chan struct{}) {
			t.Error("Unexpected call to Context.Done")
			return
		},
		ErrHook: func() (ident2 error) {
			t.Error("Unexpected call to Context.Err")
			return
		},
		ValueHook: func(interface{}) (ident3 interface{}) {
			t.Error("Unexpected call to Context.Value")
			return
		},
	}
}

func (_f1 *FakeContext) Deadline() (deadline time.Time, ok bool) {
	invocation := new(DeadlineInvocation)

	deadline, ok = _f1.DeadlineHook()

	invocation.Results.Deadline = deadline
	invocation.Results.Ok = ok

	_f1.DeadlineCalls = append(_f1.DeadlineCalls, invocation)

	return
}

// DeadlineCalled returns true if FakeContext.Deadline was called
func (f *FakeContext) DeadlineCalled() bool {
	return len(f.DeadlineCalls) != 0
}

// AssertDeadlineCalled calls t.Error if FakeContext.Deadline was not called
func (f *FakeContext) AssertDeadlineCalled(t *testing.T) {
	t.Helper()
	if len(f.DeadlineCalls) == 0 {
		t.Error("FakeContext.Deadline not called, expected at least one")
	}
}

// DeadlineNotCalled returns true if FakeContext.Deadline was not called
func (f *FakeContext) DeadlineNotCalled() bool {
	return len(f.DeadlineCalls) == 0
}

// AssertDeadlineNotCalled calls t.Error if FakeContext.Deadline was called
func (f *FakeContext) AssertDeadlineNotCalled(t *testing.T) {
	t.Helper()
	if len(f.DeadlineCalls) != 0 {
		t.Error("FakeContext.Deadline called, expected none")
	}
}

// DeadlineCalledOnce returns true if FakeContext.Deadline was called exactly once
func (f *FakeContext) DeadlineCalledOnce() bool {
	return len(f.DeadlineCalls) == 1
}

// AssertDeadlineCalledOnce calls t.Error if FakeContext.Deadline was not called exactly once
func (f *FakeContext) AssertDeadlineCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.DeadlineCalls) != 1 {
		t.Errorf("FakeContext.Deadline called %d times, expected 1", len(f.DeadlineCalls))
	}
}

// DeadlineCalledN returns true if FakeContext.Deadline was called at least n times
func (f *FakeContext) DeadlineCalledN(n int) bool {
	return len(f.DeadlineCalls) >= n
}

// AssertDeadlineCalledN calls t.Error if FakeContext.Deadline was called less than n times
func (f *FakeContext) AssertDeadlineCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.DeadlineCalls) < n {
		t.Errorf("FakeContext.Deadline called %d times, expected >= %d", len(f.DeadlineCalls), n)
	}
}

func (_f2 *FakeContext) Done() (ident1 <-chan struct{}) {
	invocation := new(DoneInvocation)

	ident1 = _f2.DoneHook()

	invocation.Results.Ident1 = ident1

	_f2.DoneCalls = append(_f2.DoneCalls, invocation)

	return
}

// DoneCalled returns true if FakeContext.Done was called
func (f *FakeContext) DoneCalled() bool {
	return len(f.DoneCalls) != 0
}

// AssertDoneCalled calls t.Error if FakeContext.Done was not called
func (f *FakeContext) AssertDoneCalled(t *testing.T) {
	t.Helper()
	if len(f.DoneCalls) == 0 {
		t.Error("FakeContext.Done not called, expected at least one")
	}
}

// DoneNotCalled returns true if FakeContext.Done was not called
func (f *FakeContext) DoneNotCalled() bool {
	return len(f.DoneCalls) == 0
}

// AssertDoneNotCalled calls t.Error if FakeContext.Done was called
func (f *FakeContext) AssertDoneNotCalled(t *testing.T) {
	t.Helper()
	if len(f.DoneCalls) != 0 {
		t.Error("FakeContext.Done called, expected none")
	}
}

// DoneCalledOnce returns true if FakeContext.Done was called exactly once
func (f *FakeContext) DoneCalledOnce() bool {
	return len(f.DoneCalls) == 1
}

// AssertDoneCalledOnce calls t.Error if FakeContext.Done was not called exactly once
func (f *FakeContext) AssertDoneCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.DoneCalls) != 1 {
		t.Errorf("FakeContext.Done called %d times, expected 1", len(f.DoneCalls))
	}
}

// DoneCalledN returns true if FakeContext.Done was called at least n times
func (f *FakeContext) DoneCalledN(n int) bool {
	return len(f.DoneCalls) >= n
}

// AssertDoneCalledN calls t.Error if FakeContext.Done was called less than n times
func (f *FakeContext) AssertDoneCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.DoneCalls) < n {
		t.Errorf("FakeContext.Done called %d times, expected >= %d", len(f.DoneCalls), n)
	}
}

func (_f3 *FakeContext) Err() (ident2 error) {
	invocation := new(ErrInvocation)

	ident2 = _f3.ErrHook()

	invocation.Results.Ident2 = ident2

	_f3.ErrCalls = append(_f3.ErrCalls, invocation)

	return
}

// ErrCalled returns true if FakeContext.Err was called
func (f *FakeContext) ErrCalled() bool {
	return len(f.ErrCalls) != 0
}

// AssertErrCalled calls t.Error if FakeContext.Err was not called
func (f *FakeContext) AssertErrCalled(t *testing.T) {
	t.Helper()
	if len(f.ErrCalls) == 0 {
		t.Error("FakeContext.Err not called, expected at least one")
	}
}

// ErrNotCalled returns true if FakeContext.Err was not called
func (f *FakeContext) ErrNotCalled() bool {
	return len(f.ErrCalls) == 0
}

// AssertErrNotCalled calls t.Error if FakeContext.Err was called
func (f *FakeContext) AssertErrNotCalled(t *testing.T) {
	t.Helper()
	if len(f.ErrCalls) != 0 {
		t.Error("FakeContext.Err called, expected none")
	}
}

// ErrCalledOnce returns true if FakeContext.Err was called exactly once
func (f *FakeContext) ErrCalledOnce() bool {
	return len(f.ErrCalls) == 1
}

// AssertErrCalledOnce calls t.Error if FakeContext.Err was not called exactly once
func (f *FakeContext) AssertErrCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.ErrCalls) != 1 {
		t.Errorf("FakeContext.Err called %d times, expected 1", len(f.ErrCalls))
	}
}

// ErrCalledN returns true if FakeContext.Err was called at least n times
func (f *FakeContext) ErrCalledN(n int) bool {
	return len(f.ErrCalls) >= n
}

// AssertErrCalledN calls t.Error if FakeContext.Err was called less than n times
func (f *FakeContext) AssertErrCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.ErrCalls) < n {
		t.Errorf("FakeContext.Err called %d times, expected >= %d", len(f.ErrCalls), n)
	}
}

func (_f4 *FakeContext) Value(key interface{}) (ident3 interface{}) {
	invocation := new(ValueInvocation)

	invocation.Parameters.Key = key

	ident3 = _f4.ValueHook(key)

	invocation.Results.Ident3 = ident3

	_f4.ValueCalls = append(_f4.ValueCalls, invocation)

	return
}

// ValueCalled returns true if FakeContext.Value was called
func (f *FakeContext) ValueCalled() bool {
	return len(f.ValueCalls) != 0
}

// AssertValueCalled calls t.Error if FakeContext.Value was not called
func (f *FakeContext) AssertValueCalled(t *testing.T) {
	t.Helper()
	if len(f.ValueCalls) == 0 {
		t.Error("FakeContext.Value not called, expected at least one")
	}
}

// ValueNotCalled returns true if FakeContext.Value was not called
func (f *FakeContext) ValueNotCalled() bool {
	return len(f.ValueCalls) == 0
}

// AssertValueNotCalled calls t.Error if FakeContext.Value was called
func (f *FakeContext) AssertValueNotCalled(t *testing.T) {
	t.Helper()
	if len(f.ValueCalls) != 0 {
		t.Error("FakeContext.Value called, expected none")
	}
}

// ValueCalledOnce returns true if FakeContext.Value was called exactly once
func (f *FakeContext) ValueCalledOnce() bool {
	return len(f.ValueCalls) == 1
}

// AssertValueCalledOnce calls t.Error if FakeContext.Value was not called exactly once
func (f *FakeContext) AssertValueCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.ValueCalls) != 1 {
		t.Errorf("FakeContext.Value called %d times, expected 1", len(f.ValueCalls))
	}
}

// ValueCalledN returns true if FakeContext.Value was called at least n times
func (f *FakeContext) ValueCalledN(n int) bool {
	return len(f.ValueCalls) >= n
}

// AssertValueCalledN calls t.Error if FakeContext.Value was called less than n times
func (f *FakeContext) AssertValueCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.ValueCalls) < n {
		t.Errorf("FakeContext.Value called %d times, expected >= %d", len(f.ValueCalls), n)
	}
}

// ValueCalledWith returns true if FakeContext.Value was called with the given values
func (_f5 *FakeContext) ValueCalledWith(key interface{}) (found bool) {
	for _, call := range _f5.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			found = true
			break
		}
	}

	return
}

// AssertValueCalledWith calls t.Error if FakeContext.Value was not called with the given values
func (_f6 *FakeContext) AssertValueCalledWith(t *testing.T, key interface{}) {
	t.Helper()
	var found bool
	for _, call := range _f6.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.Value not called with expected parameters")
	}
}

// ValueCalledOnceWith returns true if FakeContext.Value was called exactly once with the given values
func (_f7 *FakeContext) ValueCalledOnceWith(key interface{}) bool {
	var count int
	for _, call := range _f7.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			count++
		}
	}

	return count == 1
}

// AssertValueCalledOnceWith calls t.Error if FakeContext.Value was not called exactly once with the given values
func (_f8 *FakeContext) AssertValueOnceCalledWith(t *testing.T, key interface{}) {
	t.Helper()
	var count int
	for _, call := range _f8.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.Value called %d times with expected parameters, expected one", count)
	}
}

// ValueResultsForCall returns the result values for the first call to FakeContext.Value with the given values
func (_f9 *FakeContext) ValueResultsForCall(key interface{}) (ident3 interface{}, found bool) {
	for _, call := range _f9.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			ident3 = call.Results.Ident3
			found = true
			break
		}
	}

	return
}
