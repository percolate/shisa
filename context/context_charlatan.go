// generated by "charlatan -output=./context_charlatan.go Context".  DO NOT EDIT.

package context

import (
	"context"
	"reflect"
	"testing"
	"time"

	"github.com/percolate/shisa/models"
)

// ContextDeadlineInvocation represents a single call of FakeContext.Deadline
type ContextDeadlineInvocation struct {
	Results struct {
		Deadline time.Time
		Ok       bool
	}
}

// ContextDoneInvocation represents a single call of FakeContext.Done
type ContextDoneInvocation struct {
	Results struct {
		Ident1 <-chan struct{}
	}
}

// ContextErrInvocation represents a single call of FakeContext.Err
type ContextErrInvocation struct {
	Results struct {
		Ident2 error
	}
}

// ContextValueInvocation represents a single call of FakeContext.Value
type ContextValueInvocation struct {
	Parameters struct {
		Key interface{}
	}
	Results struct {
		Ident3 interface{}
	}
}

// ContextRequestIDInvocation represents a single call of FakeContext.RequestID
type ContextRequestIDInvocation struct {
	Results struct {
		Ident1 string
	}
}

// ContextActorInvocation represents a single call of FakeContext.Actor
type ContextActorInvocation struct {
	Results struct {
		Ident1 models.User
	}
}

// ContextWithActorInvocation represents a single call of FakeContext.WithActor
type ContextWithActorInvocation struct {
	Parameters struct {
		Value models.User
	}
	Results struct {
		Ident1 Context
	}
}

// ContextWithRequestIDInvocation represents a single call of FakeContext.WithRequestID
type ContextWithRequestIDInvocation struct {
	Parameters struct {
		Value string
	}
	Results struct {
		Ident1 Context
	}
}

// ContextWithValueInvocation represents a single call of FakeContext.WithValue
type ContextWithValueInvocation struct {
	Parameters struct {
		Key   interface{}
		Value interface{}
	}
	Results struct {
		Ident1 Context
	}
}

// ContextWithDeadlineInvocation represents a single call of FakeContext.WithDeadline
type ContextWithDeadlineInvocation struct {
	Parameters struct {
		Deadline time.Time
	}
	Results struct {
		Ident1 Context
		Ident2 context.CancelFunc
	}
}

// ContextWithTimeoutInvocation represents a single call of FakeContext.WithTimeout
type ContextWithTimeoutInvocation struct {
	Parameters struct {
		Timeout time.Duration
	}
	Results struct {
		Ident1 Context
		Ident2 context.CancelFunc
	}
}

/*
FakeContext is a mock implementation of Context for testing.
Use it in your tests as in this example:

	package example

	func TestWithContext(t *testing.T) {
		f := &context.FakeContext{
			DeadlineHook: func() (deadline time.Time, ok bool) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeDeadline ...
		f.AssertDeadlineCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeDeadline.
*/
type FakeContext struct {
	DeadlineHook      func() (time.Time, bool)
	DoneHook          func() <-chan struct{}
	ErrHook           func() error
	ValueHook         func(interface{}) interface{}
	RequestIDHook     func() string
	ActorHook         func() models.User
	WithActorHook     func(models.User) Context
	WithRequestIDHook func(string) Context
	WithValueHook     func(interface{}, interface{}) Context
	WithDeadlineHook  func(time.Time) (Context, context.CancelFunc)
	WithTimeoutHook   func(time.Duration) (Context, context.CancelFunc)

	DeadlineCalls      []*ContextDeadlineInvocation
	DoneCalls          []*ContextDoneInvocation
	ErrCalls           []*ContextErrInvocation
	ValueCalls         []*ContextValueInvocation
	RequestIDCalls     []*ContextRequestIDInvocation
	ActorCalls         []*ContextActorInvocation
	WithActorCalls     []*ContextWithActorInvocation
	WithRequestIDCalls []*ContextWithRequestIDInvocation
	WithValueCalls     []*ContextWithValueInvocation
	WithDeadlineCalls  []*ContextWithDeadlineInvocation
	WithTimeoutCalls   []*ContextWithTimeoutInvocation
}

// NewFakeContextDefaultPanic returns an instance of FakeContext with all hooks configured to panic
func NewFakeContextDefaultPanic() *FakeContext {
	return &FakeContext{
		DeadlineHook: func() (deadline time.Time, ok bool) {
			panic("Unexpected call to Context.Deadline")
		},
		DoneHook: func() (ident1 <-chan struct{}) {
			panic("Unexpected call to Context.Done")
		},
		ErrHook: func() (ident2 error) {
			panic("Unexpected call to Context.Err")
		},
		ValueHook: func(interface{}) (ident3 interface{}) {
			panic("Unexpected call to Context.Value")
		},
		RequestIDHook: func() (ident1 string) {
			panic("Unexpected call to Context.RequestID")
		},
		ActorHook: func() (ident1 models.User) {
			panic("Unexpected call to Context.Actor")
		},
		WithActorHook: func(models.User) (ident1 Context) {
			panic("Unexpected call to Context.WithActor")
		},
		WithRequestIDHook: func(string) (ident1 Context) {
			panic("Unexpected call to Context.WithRequestID")
		},
		WithValueHook: func(interface{}, interface{}) (ident1 Context) {
			panic("Unexpected call to Context.WithValue")
		},
		WithDeadlineHook: func(time.Time) (ident1 Context, ident2 context.CancelFunc) {
			panic("Unexpected call to Context.WithDeadline")
		},
		WithTimeoutHook: func(time.Duration) (ident1 Context, ident2 context.CancelFunc) {
			panic("Unexpected call to Context.WithTimeout")
		},
	}
}

// NewFakeContextDefaultFatal returns an instance of FakeContext with all hooks configured to call t.Fatal
func NewFakeContextDefaultFatal(t *testing.T) *FakeContext {
	return &FakeContext{
		DeadlineHook: func() (deadline time.Time, ok bool) {
			t.Fatal("Unexpected call to Context.Deadline")
			return
		},
		DoneHook: func() (ident1 <-chan struct{}) {
			t.Fatal("Unexpected call to Context.Done")
			return
		},
		ErrHook: func() (ident2 error) {
			t.Fatal("Unexpected call to Context.Err")
			return
		},
		ValueHook: func(interface{}) (ident3 interface{}) {
			t.Fatal("Unexpected call to Context.Value")
			return
		},
		RequestIDHook: func() (ident1 string) {
			t.Fatal("Unexpected call to Context.RequestID")
			return
		},
		ActorHook: func() (ident1 models.User) {
			t.Fatal("Unexpected call to Context.Actor")
			return
		},
		WithActorHook: func(models.User) (ident1 Context) {
			t.Fatal("Unexpected call to Context.WithActor")
			return
		},
		WithRequestIDHook: func(string) (ident1 Context) {
			t.Fatal("Unexpected call to Context.WithRequestID")
			return
		},
		WithValueHook: func(interface{}, interface{}) (ident1 Context) {
			t.Fatal("Unexpected call to Context.WithValue")
			return
		},
		WithDeadlineHook: func(time.Time) (ident1 Context, ident2 context.CancelFunc) {
			t.Fatal("Unexpected call to Context.WithDeadline")
			return
		},
		WithTimeoutHook: func(time.Duration) (ident1 Context, ident2 context.CancelFunc) {
			t.Fatal("Unexpected call to Context.WithTimeout")
			return
		},
	}
}

// NewFakeContextDefaultError returns an instance of FakeContext with all hooks configured to call t.Error
func NewFakeContextDefaultError(t *testing.T) *FakeContext {
	return &FakeContext{
		DeadlineHook: func() (deadline time.Time, ok bool) {
			t.Error("Unexpected call to Context.Deadline")
			return
		},
		DoneHook: func() (ident1 <-chan struct{}) {
			t.Error("Unexpected call to Context.Done")
			return
		},
		ErrHook: func() (ident2 error) {
			t.Error("Unexpected call to Context.Err")
			return
		},
		ValueHook: func(interface{}) (ident3 interface{}) {
			t.Error("Unexpected call to Context.Value")
			return
		},
		RequestIDHook: func() (ident1 string) {
			t.Error("Unexpected call to Context.RequestID")
			return
		},
		ActorHook: func() (ident1 models.User) {
			t.Error("Unexpected call to Context.Actor")
			return
		},
		WithActorHook: func(models.User) (ident1 Context) {
			t.Error("Unexpected call to Context.WithActor")
			return
		},
		WithRequestIDHook: func(string) (ident1 Context) {
			t.Error("Unexpected call to Context.WithRequestID")
			return
		},
		WithValueHook: func(interface{}, interface{}) (ident1 Context) {
			t.Error("Unexpected call to Context.WithValue")
			return
		},
		WithDeadlineHook: func(time.Time) (ident1 Context, ident2 context.CancelFunc) {
			t.Error("Unexpected call to Context.WithDeadline")
			return
		},
		WithTimeoutHook: func(time.Duration) (ident1 Context, ident2 context.CancelFunc) {
			t.Error("Unexpected call to Context.WithTimeout")
			return
		},
	}
}

func (f *FakeContext) Reset() {
	f.DeadlineCalls = []*ContextDeadlineInvocation{}
	f.DoneCalls = []*ContextDoneInvocation{}
	f.ErrCalls = []*ContextErrInvocation{}
	f.ValueCalls = []*ContextValueInvocation{}
	f.RequestIDCalls = []*ContextRequestIDInvocation{}
	f.ActorCalls = []*ContextActorInvocation{}
	f.WithActorCalls = []*ContextWithActorInvocation{}
	f.WithRequestIDCalls = []*ContextWithRequestIDInvocation{}
	f.WithValueCalls = []*ContextWithValueInvocation{}
	f.WithDeadlineCalls = []*ContextWithDeadlineInvocation{}
	f.WithTimeoutCalls = []*ContextWithTimeoutInvocation{}
}

func (_f1 *FakeContext) Deadline() (deadline time.Time, ok bool) {
	invocation := new(ContextDeadlineInvocation)

	deadline, ok = _f1.DeadlineHook()

	invocation.Results.Deadline = deadline
	invocation.Results.Ok = ok

	_f1.DeadlineCalls = append(_f1.DeadlineCalls, invocation)

	return
}

// DeadlineCalled returns true if FakeContext.Deadline was called
func (f *FakeContext) DeadlineCalled() bool {
	return len(f.DeadlineCalls) != 0
}

// AssertDeadlineCalled calls t.Error if FakeContext.Deadline was not called
func (f *FakeContext) AssertDeadlineCalled(t *testing.T) {
	t.Helper()
	if len(f.DeadlineCalls) == 0 {
		t.Error("FakeContext.Deadline not called, expected at least one")
	}
}

// DeadlineNotCalled returns true if FakeContext.Deadline was not called
func (f *FakeContext) DeadlineNotCalled() bool {
	return len(f.DeadlineCalls) == 0
}

// AssertDeadlineNotCalled calls t.Error if FakeContext.Deadline was called
func (f *FakeContext) AssertDeadlineNotCalled(t *testing.T) {
	t.Helper()
	if len(f.DeadlineCalls) != 0 {
		t.Error("FakeContext.Deadline called, expected none")
	}
}

// DeadlineCalledOnce returns true if FakeContext.Deadline was called exactly once
func (f *FakeContext) DeadlineCalledOnce() bool {
	return len(f.DeadlineCalls) == 1
}

// AssertDeadlineCalledOnce calls t.Error if FakeContext.Deadline was not called exactly once
func (f *FakeContext) AssertDeadlineCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.DeadlineCalls) != 1 {
		t.Errorf("FakeContext.Deadline called %d times, expected 1", len(f.DeadlineCalls))
	}
}

// DeadlineCalledN returns true if FakeContext.Deadline was called at least n times
func (f *FakeContext) DeadlineCalledN(n int) bool {
	return len(f.DeadlineCalls) >= n
}

// AssertDeadlineCalledN calls t.Error if FakeContext.Deadline was called less than n times
func (f *FakeContext) AssertDeadlineCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.DeadlineCalls) < n {
		t.Errorf("FakeContext.Deadline called %d times, expected >= %d", len(f.DeadlineCalls), n)
	}
}

func (_f2 *FakeContext) Done() (ident1 <-chan struct{}) {
	invocation := new(ContextDoneInvocation)

	ident1 = _f2.DoneHook()

	invocation.Results.Ident1 = ident1

	_f2.DoneCalls = append(_f2.DoneCalls, invocation)

	return
}

// DoneCalled returns true if FakeContext.Done was called
func (f *FakeContext) DoneCalled() bool {
	return len(f.DoneCalls) != 0
}

// AssertDoneCalled calls t.Error if FakeContext.Done was not called
func (f *FakeContext) AssertDoneCalled(t *testing.T) {
	t.Helper()
	if len(f.DoneCalls) == 0 {
		t.Error("FakeContext.Done not called, expected at least one")
	}
}

// DoneNotCalled returns true if FakeContext.Done was not called
func (f *FakeContext) DoneNotCalled() bool {
	return len(f.DoneCalls) == 0
}

// AssertDoneNotCalled calls t.Error if FakeContext.Done was called
func (f *FakeContext) AssertDoneNotCalled(t *testing.T) {
	t.Helper()
	if len(f.DoneCalls) != 0 {
		t.Error("FakeContext.Done called, expected none")
	}
}

// DoneCalledOnce returns true if FakeContext.Done was called exactly once
func (f *FakeContext) DoneCalledOnce() bool {
	return len(f.DoneCalls) == 1
}

// AssertDoneCalledOnce calls t.Error if FakeContext.Done was not called exactly once
func (f *FakeContext) AssertDoneCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.DoneCalls) != 1 {
		t.Errorf("FakeContext.Done called %d times, expected 1", len(f.DoneCalls))
	}
}

// DoneCalledN returns true if FakeContext.Done was called at least n times
func (f *FakeContext) DoneCalledN(n int) bool {
	return len(f.DoneCalls) >= n
}

// AssertDoneCalledN calls t.Error if FakeContext.Done was called less than n times
func (f *FakeContext) AssertDoneCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.DoneCalls) < n {
		t.Errorf("FakeContext.Done called %d times, expected >= %d", len(f.DoneCalls), n)
	}
}

func (_f3 *FakeContext) Err() (ident2 error) {
	invocation := new(ContextErrInvocation)

	ident2 = _f3.ErrHook()

	invocation.Results.Ident2 = ident2

	_f3.ErrCalls = append(_f3.ErrCalls, invocation)

	return
}

// ErrCalled returns true if FakeContext.Err was called
func (f *FakeContext) ErrCalled() bool {
	return len(f.ErrCalls) != 0
}

// AssertErrCalled calls t.Error if FakeContext.Err was not called
func (f *FakeContext) AssertErrCalled(t *testing.T) {
	t.Helper()
	if len(f.ErrCalls) == 0 {
		t.Error("FakeContext.Err not called, expected at least one")
	}
}

// ErrNotCalled returns true if FakeContext.Err was not called
func (f *FakeContext) ErrNotCalled() bool {
	return len(f.ErrCalls) == 0
}

// AssertErrNotCalled calls t.Error if FakeContext.Err was called
func (f *FakeContext) AssertErrNotCalled(t *testing.T) {
	t.Helper()
	if len(f.ErrCalls) != 0 {
		t.Error("FakeContext.Err called, expected none")
	}
}

// ErrCalledOnce returns true if FakeContext.Err was called exactly once
func (f *FakeContext) ErrCalledOnce() bool {
	return len(f.ErrCalls) == 1
}

// AssertErrCalledOnce calls t.Error if FakeContext.Err was not called exactly once
func (f *FakeContext) AssertErrCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.ErrCalls) != 1 {
		t.Errorf("FakeContext.Err called %d times, expected 1", len(f.ErrCalls))
	}
}

// ErrCalledN returns true if FakeContext.Err was called at least n times
func (f *FakeContext) ErrCalledN(n int) bool {
	return len(f.ErrCalls) >= n
}

// AssertErrCalledN calls t.Error if FakeContext.Err was called less than n times
func (f *FakeContext) AssertErrCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.ErrCalls) < n {
		t.Errorf("FakeContext.Err called %d times, expected >= %d", len(f.ErrCalls), n)
	}
}

func (_f4 *FakeContext) Value(key interface{}) (ident3 interface{}) {
	invocation := new(ContextValueInvocation)

	invocation.Parameters.Key = key

	ident3 = _f4.ValueHook(key)

	invocation.Results.Ident3 = ident3

	_f4.ValueCalls = append(_f4.ValueCalls, invocation)

	return
}

// ValueCalled returns true if FakeContext.Value was called
func (f *FakeContext) ValueCalled() bool {
	return len(f.ValueCalls) != 0
}

// AssertValueCalled calls t.Error if FakeContext.Value was not called
func (f *FakeContext) AssertValueCalled(t *testing.T) {
	t.Helper()
	if len(f.ValueCalls) == 0 {
		t.Error("FakeContext.Value not called, expected at least one")
	}
}

// ValueNotCalled returns true if FakeContext.Value was not called
func (f *FakeContext) ValueNotCalled() bool {
	return len(f.ValueCalls) == 0
}

// AssertValueNotCalled calls t.Error if FakeContext.Value was called
func (f *FakeContext) AssertValueNotCalled(t *testing.T) {
	t.Helper()
	if len(f.ValueCalls) != 0 {
		t.Error("FakeContext.Value called, expected none")
	}
}

// ValueCalledOnce returns true if FakeContext.Value was called exactly once
func (f *FakeContext) ValueCalledOnce() bool {
	return len(f.ValueCalls) == 1
}

// AssertValueCalledOnce calls t.Error if FakeContext.Value was not called exactly once
func (f *FakeContext) AssertValueCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.ValueCalls) != 1 {
		t.Errorf("FakeContext.Value called %d times, expected 1", len(f.ValueCalls))
	}
}

// ValueCalledN returns true if FakeContext.Value was called at least n times
func (f *FakeContext) ValueCalledN(n int) bool {
	return len(f.ValueCalls) >= n
}

// AssertValueCalledN calls t.Error if FakeContext.Value was called less than n times
func (f *FakeContext) AssertValueCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.ValueCalls) < n {
		t.Errorf("FakeContext.Value called %d times, expected >= %d", len(f.ValueCalls), n)
	}
}

// ValueCalledWith returns true if FakeContext.Value was called with the given values
func (_f5 *FakeContext) ValueCalledWith(key interface{}) (found bool) {
	for _, call := range _f5.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			found = true
			break
		}
	}

	return
}

// AssertValueCalledWith calls t.Error if FakeContext.Value was not called with the given values
func (_f6 *FakeContext) AssertValueCalledWith(t *testing.T, key interface{}) {
	t.Helper()
	var found bool
	for _, call := range _f6.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.Value not called with expected parameters")
	}
}

// ValueCalledOnceWith returns true if FakeContext.Value was called exactly once with the given values
func (_f7 *FakeContext) ValueCalledOnceWith(key interface{}) bool {
	var count int
	for _, call := range _f7.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			count++
		}
	}

	return count == 1
}

// AssertValueCalledOnceWith calls t.Error if FakeContext.Value was not called exactly once with the given values
func (_f8 *FakeContext) AssertValueCalledOnceWith(t *testing.T, key interface{}) {
	t.Helper()
	var count int
	for _, call := range _f8.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.Value called %d times with expected parameters, expected one", count)
	}
}

// ValueResultsForCall returns the result values for the first call to FakeContext.Value with the given values
func (_f9 *FakeContext) ValueResultsForCall(key interface{}) (ident3 interface{}, found bool) {
	for _, call := range _f9.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			ident3 = call.Results.Ident3
			found = true
			break
		}
	}

	return
}

func (_f10 *FakeContext) RequestID() (ident1 string) {
	invocation := new(ContextRequestIDInvocation)

	ident1 = _f10.RequestIDHook()

	invocation.Results.Ident1 = ident1

	_f10.RequestIDCalls = append(_f10.RequestIDCalls, invocation)

	return
}

// RequestIDCalled returns true if FakeContext.RequestID was called
func (f *FakeContext) RequestIDCalled() bool {
	return len(f.RequestIDCalls) != 0
}

// AssertRequestIDCalled calls t.Error if FakeContext.RequestID was not called
func (f *FakeContext) AssertRequestIDCalled(t *testing.T) {
	t.Helper()
	if len(f.RequestIDCalls) == 0 {
		t.Error("FakeContext.RequestID not called, expected at least one")
	}
}

// RequestIDNotCalled returns true if FakeContext.RequestID was not called
func (f *FakeContext) RequestIDNotCalled() bool {
	return len(f.RequestIDCalls) == 0
}

// AssertRequestIDNotCalled calls t.Error if FakeContext.RequestID was called
func (f *FakeContext) AssertRequestIDNotCalled(t *testing.T) {
	t.Helper()
	if len(f.RequestIDCalls) != 0 {
		t.Error("FakeContext.RequestID called, expected none")
	}
}

// RequestIDCalledOnce returns true if FakeContext.RequestID was called exactly once
func (f *FakeContext) RequestIDCalledOnce() bool {
	return len(f.RequestIDCalls) == 1
}

// AssertRequestIDCalledOnce calls t.Error if FakeContext.RequestID was not called exactly once
func (f *FakeContext) AssertRequestIDCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.RequestIDCalls) != 1 {
		t.Errorf("FakeContext.RequestID called %d times, expected 1", len(f.RequestIDCalls))
	}
}

// RequestIDCalledN returns true if FakeContext.RequestID was called at least n times
func (f *FakeContext) RequestIDCalledN(n int) bool {
	return len(f.RequestIDCalls) >= n
}

// AssertRequestIDCalledN calls t.Error if FakeContext.RequestID was called less than n times
func (f *FakeContext) AssertRequestIDCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.RequestIDCalls) < n {
		t.Errorf("FakeContext.RequestID called %d times, expected >= %d", len(f.RequestIDCalls), n)
	}
}

func (_f11 *FakeContext) Actor() (ident1 models.User) {
	invocation := new(ContextActorInvocation)

	ident1 = _f11.ActorHook()

	invocation.Results.Ident1 = ident1

	_f11.ActorCalls = append(_f11.ActorCalls, invocation)

	return
}

// ActorCalled returns true if FakeContext.Actor was called
func (f *FakeContext) ActorCalled() bool {
	return len(f.ActorCalls) != 0
}

// AssertActorCalled calls t.Error if FakeContext.Actor was not called
func (f *FakeContext) AssertActorCalled(t *testing.T) {
	t.Helper()
	if len(f.ActorCalls) == 0 {
		t.Error("FakeContext.Actor not called, expected at least one")
	}
}

// ActorNotCalled returns true if FakeContext.Actor was not called
func (f *FakeContext) ActorNotCalled() bool {
	return len(f.ActorCalls) == 0
}

// AssertActorNotCalled calls t.Error if FakeContext.Actor was called
func (f *FakeContext) AssertActorNotCalled(t *testing.T) {
	t.Helper()
	if len(f.ActorCalls) != 0 {
		t.Error("FakeContext.Actor called, expected none")
	}
}

// ActorCalledOnce returns true if FakeContext.Actor was called exactly once
func (f *FakeContext) ActorCalledOnce() bool {
	return len(f.ActorCalls) == 1
}

// AssertActorCalledOnce calls t.Error if FakeContext.Actor was not called exactly once
func (f *FakeContext) AssertActorCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.ActorCalls) != 1 {
		t.Errorf("FakeContext.Actor called %d times, expected 1", len(f.ActorCalls))
	}
}

// ActorCalledN returns true if FakeContext.Actor was called at least n times
func (f *FakeContext) ActorCalledN(n int) bool {
	return len(f.ActorCalls) >= n
}

// AssertActorCalledN calls t.Error if FakeContext.Actor was called less than n times
func (f *FakeContext) AssertActorCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.ActorCalls) < n {
		t.Errorf("FakeContext.Actor called %d times, expected >= %d", len(f.ActorCalls), n)
	}
}

func (_f12 *FakeContext) WithActor(value models.User) (ident1 Context) {
	invocation := new(ContextWithActorInvocation)

	invocation.Parameters.Value = value

	ident1 = _f12.WithActorHook(value)

	invocation.Results.Ident1 = ident1

	_f12.WithActorCalls = append(_f12.WithActorCalls, invocation)

	return
}

// WithActorCalled returns true if FakeContext.WithActor was called
func (f *FakeContext) WithActorCalled() bool {
	return len(f.WithActorCalls) != 0
}

// AssertWithActorCalled calls t.Error if FakeContext.WithActor was not called
func (f *FakeContext) AssertWithActorCalled(t *testing.T) {
	t.Helper()
	if len(f.WithActorCalls) == 0 {
		t.Error("FakeContext.WithActor not called, expected at least one")
	}
}

// WithActorNotCalled returns true if FakeContext.WithActor was not called
func (f *FakeContext) WithActorNotCalled() bool {
	return len(f.WithActorCalls) == 0
}

// AssertWithActorNotCalled calls t.Error if FakeContext.WithActor was called
func (f *FakeContext) AssertWithActorNotCalled(t *testing.T) {
	t.Helper()
	if len(f.WithActorCalls) != 0 {
		t.Error("FakeContext.WithActor called, expected none")
	}
}

// WithActorCalledOnce returns true if FakeContext.WithActor was called exactly once
func (f *FakeContext) WithActorCalledOnce() bool {
	return len(f.WithActorCalls) == 1
}

// AssertWithActorCalledOnce calls t.Error if FakeContext.WithActor was not called exactly once
func (f *FakeContext) AssertWithActorCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.WithActorCalls) != 1 {
		t.Errorf("FakeContext.WithActor called %d times, expected 1", len(f.WithActorCalls))
	}
}

// WithActorCalledN returns true if FakeContext.WithActor was called at least n times
func (f *FakeContext) WithActorCalledN(n int) bool {
	return len(f.WithActorCalls) >= n
}

// AssertWithActorCalledN calls t.Error if FakeContext.WithActor was called less than n times
func (f *FakeContext) AssertWithActorCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.WithActorCalls) < n {
		t.Errorf("FakeContext.WithActor called %d times, expected >= %d", len(f.WithActorCalls), n)
	}
}

// WithActorCalledWith returns true if FakeContext.WithActor was called with the given values
func (_f13 *FakeContext) WithActorCalledWith(value models.User) (found bool) {
	for _, call := range _f13.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Value, value) {
			found = true
			break
		}
	}

	return
}

// AssertWithActorCalledWith calls t.Error if FakeContext.WithActor was not called with the given values
func (_f14 *FakeContext) AssertWithActorCalledWith(t *testing.T, value models.User) {
	t.Helper()
	var found bool
	for _, call := range _f14.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Value, value) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithActor not called with expected parameters")
	}
}

// WithActorCalledOnceWith returns true if FakeContext.WithActor was called exactly once with the given values
func (_f15 *FakeContext) WithActorCalledOnceWith(value models.User) bool {
	var count int
	for _, call := range _f15.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Value, value) {
			count++
		}
	}

	return count == 1
}

// AssertWithActorCalledOnceWith calls t.Error if FakeContext.WithActor was not called exactly once with the given values
func (_f16 *FakeContext) AssertWithActorCalledOnceWith(t *testing.T, value models.User) {
	t.Helper()
	var count int
	for _, call := range _f16.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Value, value) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithActor called %d times with expected parameters, expected one", count)
	}
}

// WithActorResultsForCall returns the result values for the first call to FakeContext.WithActor with the given values
func (_f17 *FakeContext) WithActorResultsForCall(value models.User) (ident1 Context, found bool) {
	for _, call := range _f17.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Value, value) {
			ident1 = call.Results.Ident1
			found = true
			break
		}
	}

	return
}

func (_f18 *FakeContext) WithRequestID(value string) (ident1 Context) {
	invocation := new(ContextWithRequestIDInvocation)

	invocation.Parameters.Value = value

	ident1 = _f18.WithRequestIDHook(value)

	invocation.Results.Ident1 = ident1

	_f18.WithRequestIDCalls = append(_f18.WithRequestIDCalls, invocation)

	return
}

// WithRequestIDCalled returns true if FakeContext.WithRequestID was called
func (f *FakeContext) WithRequestIDCalled() bool {
	return len(f.WithRequestIDCalls) != 0
}

// AssertWithRequestIDCalled calls t.Error if FakeContext.WithRequestID was not called
func (f *FakeContext) AssertWithRequestIDCalled(t *testing.T) {
	t.Helper()
	if len(f.WithRequestIDCalls) == 0 {
		t.Error("FakeContext.WithRequestID not called, expected at least one")
	}
}

// WithRequestIDNotCalled returns true if FakeContext.WithRequestID was not called
func (f *FakeContext) WithRequestIDNotCalled() bool {
	return len(f.WithRequestIDCalls) == 0
}

// AssertWithRequestIDNotCalled calls t.Error if FakeContext.WithRequestID was called
func (f *FakeContext) AssertWithRequestIDNotCalled(t *testing.T) {
	t.Helper()
	if len(f.WithRequestIDCalls) != 0 {
		t.Error("FakeContext.WithRequestID called, expected none")
	}
}

// WithRequestIDCalledOnce returns true if FakeContext.WithRequestID was called exactly once
func (f *FakeContext) WithRequestIDCalledOnce() bool {
	return len(f.WithRequestIDCalls) == 1
}

// AssertWithRequestIDCalledOnce calls t.Error if FakeContext.WithRequestID was not called exactly once
func (f *FakeContext) AssertWithRequestIDCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.WithRequestIDCalls) != 1 {
		t.Errorf("FakeContext.WithRequestID called %d times, expected 1", len(f.WithRequestIDCalls))
	}
}

// WithRequestIDCalledN returns true if FakeContext.WithRequestID was called at least n times
func (f *FakeContext) WithRequestIDCalledN(n int) bool {
	return len(f.WithRequestIDCalls) >= n
}

// AssertWithRequestIDCalledN calls t.Error if FakeContext.WithRequestID was called less than n times
func (f *FakeContext) AssertWithRequestIDCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.WithRequestIDCalls) < n {
		t.Errorf("FakeContext.WithRequestID called %d times, expected >= %d", len(f.WithRequestIDCalls), n)
	}
}

// WithRequestIDCalledWith returns true if FakeContext.WithRequestID was called with the given values
func (_f19 *FakeContext) WithRequestIDCalledWith(value string) (found bool) {
	for _, call := range _f19.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Value, value) {
			found = true
			break
		}
	}

	return
}

// AssertWithRequestIDCalledWith calls t.Error if FakeContext.WithRequestID was not called with the given values
func (_f20 *FakeContext) AssertWithRequestIDCalledWith(t *testing.T, value string) {
	t.Helper()
	var found bool
	for _, call := range _f20.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Value, value) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithRequestID not called with expected parameters")
	}
}

// WithRequestIDCalledOnceWith returns true if FakeContext.WithRequestID was called exactly once with the given values
func (_f21 *FakeContext) WithRequestIDCalledOnceWith(value string) bool {
	var count int
	for _, call := range _f21.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Value, value) {
			count++
		}
	}

	return count == 1
}

// AssertWithRequestIDCalledOnceWith calls t.Error if FakeContext.WithRequestID was not called exactly once with the given values
func (_f22 *FakeContext) AssertWithRequestIDCalledOnceWith(t *testing.T, value string) {
	t.Helper()
	var count int
	for _, call := range _f22.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Value, value) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithRequestID called %d times with expected parameters, expected one", count)
	}
}

// WithRequestIDResultsForCall returns the result values for the first call to FakeContext.WithRequestID with the given values
func (_f23 *FakeContext) WithRequestIDResultsForCall(value string) (ident1 Context, found bool) {
	for _, call := range _f23.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Value, value) {
			ident1 = call.Results.Ident1
			found = true
			break
		}
	}

	return
}

func (_f24 *FakeContext) WithValue(key interface{}, value interface{}) (ident1 Context) {
	invocation := new(ContextWithValueInvocation)

	invocation.Parameters.Key = key
	invocation.Parameters.Value = value

	ident1 = _f24.WithValueHook(key, value)

	invocation.Results.Ident1 = ident1

	_f24.WithValueCalls = append(_f24.WithValueCalls, invocation)

	return
}

// WithValueCalled returns true if FakeContext.WithValue was called
func (f *FakeContext) WithValueCalled() bool {
	return len(f.WithValueCalls) != 0
}

// AssertWithValueCalled calls t.Error if FakeContext.WithValue was not called
func (f *FakeContext) AssertWithValueCalled(t *testing.T) {
	t.Helper()
	if len(f.WithValueCalls) == 0 {
		t.Error("FakeContext.WithValue not called, expected at least one")
	}
}

// WithValueNotCalled returns true if FakeContext.WithValue was not called
func (f *FakeContext) WithValueNotCalled() bool {
	return len(f.WithValueCalls) == 0
}

// AssertWithValueNotCalled calls t.Error if FakeContext.WithValue was called
func (f *FakeContext) AssertWithValueNotCalled(t *testing.T) {
	t.Helper()
	if len(f.WithValueCalls) != 0 {
		t.Error("FakeContext.WithValue called, expected none")
	}
}

// WithValueCalledOnce returns true if FakeContext.WithValue was called exactly once
func (f *FakeContext) WithValueCalledOnce() bool {
	return len(f.WithValueCalls) == 1
}

// AssertWithValueCalledOnce calls t.Error if FakeContext.WithValue was not called exactly once
func (f *FakeContext) AssertWithValueCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.WithValueCalls) != 1 {
		t.Errorf("FakeContext.WithValue called %d times, expected 1", len(f.WithValueCalls))
	}
}

// WithValueCalledN returns true if FakeContext.WithValue was called at least n times
func (f *FakeContext) WithValueCalledN(n int) bool {
	return len(f.WithValueCalls) >= n
}

// AssertWithValueCalledN calls t.Error if FakeContext.WithValue was called less than n times
func (f *FakeContext) AssertWithValueCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.WithValueCalls) < n {
		t.Errorf("FakeContext.WithValue called %d times, expected >= %d", len(f.WithValueCalls), n)
	}
}

// WithValueCalledWith returns true if FakeContext.WithValue was called with the given values
func (_f25 *FakeContext) WithValueCalledWith(key interface{}, value interface{}) (found bool) {
	for _, call := range _f25.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			found = true
			break
		}
	}

	return
}

// AssertWithValueCalledWith calls t.Error if FakeContext.WithValue was not called with the given values
func (_f26 *FakeContext) AssertWithValueCalledWith(t *testing.T, key interface{}, value interface{}) {
	t.Helper()
	var found bool
	for _, call := range _f26.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithValue not called with expected parameters")
	}
}

// WithValueCalledOnceWith returns true if FakeContext.WithValue was called exactly once with the given values
func (_f27 *FakeContext) WithValueCalledOnceWith(key interface{}, value interface{}) bool {
	var count int
	for _, call := range _f27.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			count++
		}
	}

	return count == 1
}

// AssertWithValueCalledOnceWith calls t.Error if FakeContext.WithValue was not called exactly once with the given values
func (_f28 *FakeContext) AssertWithValueCalledOnceWith(t *testing.T, key interface{}, value interface{}) {
	t.Helper()
	var count int
	for _, call := range _f28.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithValue called %d times with expected parameters, expected one", count)
	}
}

// WithValueResultsForCall returns the result values for the first call to FakeContext.WithValue with the given values
func (_f29 *FakeContext) WithValueResultsForCall(key interface{}, value interface{}) (ident1 Context, found bool) {
	for _, call := range _f29.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			ident1 = call.Results.Ident1
			found = true
			break
		}
	}

	return
}

func (_f30 *FakeContext) WithDeadline(deadline time.Time) (ident1 Context, ident2 context.CancelFunc) {
	invocation := new(ContextWithDeadlineInvocation)

	invocation.Parameters.Deadline = deadline

	ident1, ident2 = _f30.WithDeadlineHook(deadline)

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	_f30.WithDeadlineCalls = append(_f30.WithDeadlineCalls, invocation)

	return
}

// WithDeadlineCalled returns true if FakeContext.WithDeadline was called
func (f *FakeContext) WithDeadlineCalled() bool {
	return len(f.WithDeadlineCalls) != 0
}

// AssertWithDeadlineCalled calls t.Error if FakeContext.WithDeadline was not called
func (f *FakeContext) AssertWithDeadlineCalled(t *testing.T) {
	t.Helper()
	if len(f.WithDeadlineCalls) == 0 {
		t.Error("FakeContext.WithDeadline not called, expected at least one")
	}
}

// WithDeadlineNotCalled returns true if FakeContext.WithDeadline was not called
func (f *FakeContext) WithDeadlineNotCalled() bool {
	return len(f.WithDeadlineCalls) == 0
}

// AssertWithDeadlineNotCalled calls t.Error if FakeContext.WithDeadline was called
func (f *FakeContext) AssertWithDeadlineNotCalled(t *testing.T) {
	t.Helper()
	if len(f.WithDeadlineCalls) != 0 {
		t.Error("FakeContext.WithDeadline called, expected none")
	}
}

// WithDeadlineCalledOnce returns true if FakeContext.WithDeadline was called exactly once
func (f *FakeContext) WithDeadlineCalledOnce() bool {
	return len(f.WithDeadlineCalls) == 1
}

// AssertWithDeadlineCalledOnce calls t.Error if FakeContext.WithDeadline was not called exactly once
func (f *FakeContext) AssertWithDeadlineCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.WithDeadlineCalls) != 1 {
		t.Errorf("FakeContext.WithDeadline called %d times, expected 1", len(f.WithDeadlineCalls))
	}
}

// WithDeadlineCalledN returns true if FakeContext.WithDeadline was called at least n times
func (f *FakeContext) WithDeadlineCalledN(n int) bool {
	return len(f.WithDeadlineCalls) >= n
}

// AssertWithDeadlineCalledN calls t.Error if FakeContext.WithDeadline was called less than n times
func (f *FakeContext) AssertWithDeadlineCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.WithDeadlineCalls) < n {
		t.Errorf("FakeContext.WithDeadline called %d times, expected >= %d", len(f.WithDeadlineCalls), n)
	}
}

// WithDeadlineCalledWith returns true if FakeContext.WithDeadline was called with the given values
func (_f31 *FakeContext) WithDeadlineCalledWith(deadline time.Time) (found bool) {
	for _, call := range _f31.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Deadline, deadline) {
			found = true
			break
		}
	}

	return
}

// AssertWithDeadlineCalledWith calls t.Error if FakeContext.WithDeadline was not called with the given values
func (_f32 *FakeContext) AssertWithDeadlineCalledWith(t *testing.T, deadline time.Time) {
	t.Helper()
	var found bool
	for _, call := range _f32.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Deadline, deadline) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithDeadline not called with expected parameters")
	}
}

// WithDeadlineCalledOnceWith returns true if FakeContext.WithDeadline was called exactly once with the given values
func (_f33 *FakeContext) WithDeadlineCalledOnceWith(deadline time.Time) bool {
	var count int
	for _, call := range _f33.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Deadline, deadline) {
			count++
		}
	}

	return count == 1
}

// AssertWithDeadlineCalledOnceWith calls t.Error if FakeContext.WithDeadline was not called exactly once with the given values
func (_f34 *FakeContext) AssertWithDeadlineCalledOnceWith(t *testing.T, deadline time.Time) {
	t.Helper()
	var count int
	for _, call := range _f34.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Deadline, deadline) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithDeadline called %d times with expected parameters, expected one", count)
	}
}

// WithDeadlineResultsForCall returns the result values for the first call to FakeContext.WithDeadline with the given values
func (_f35 *FakeContext) WithDeadlineResultsForCall(deadline time.Time) (ident1 Context, ident2 context.CancelFunc, found bool) {
	for _, call := range _f35.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Deadline, deadline) {
			ident1 = call.Results.Ident1
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}

func (_f36 *FakeContext) WithTimeout(timeout time.Duration) (ident1 Context, ident2 context.CancelFunc) {
	invocation := new(ContextWithTimeoutInvocation)

	invocation.Parameters.Timeout = timeout

	ident1, ident2 = _f36.WithTimeoutHook(timeout)

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	_f36.WithTimeoutCalls = append(_f36.WithTimeoutCalls, invocation)

	return
}

// WithTimeoutCalled returns true if FakeContext.WithTimeout was called
func (f *FakeContext) WithTimeoutCalled() bool {
	return len(f.WithTimeoutCalls) != 0
}

// AssertWithTimeoutCalled calls t.Error if FakeContext.WithTimeout was not called
func (f *FakeContext) AssertWithTimeoutCalled(t *testing.T) {
	t.Helper()
	if len(f.WithTimeoutCalls) == 0 {
		t.Error("FakeContext.WithTimeout not called, expected at least one")
	}
}

// WithTimeoutNotCalled returns true if FakeContext.WithTimeout was not called
func (f *FakeContext) WithTimeoutNotCalled() bool {
	return len(f.WithTimeoutCalls) == 0
}

// AssertWithTimeoutNotCalled calls t.Error if FakeContext.WithTimeout was called
func (f *FakeContext) AssertWithTimeoutNotCalled(t *testing.T) {
	t.Helper()
	if len(f.WithTimeoutCalls) != 0 {
		t.Error("FakeContext.WithTimeout called, expected none")
	}
}

// WithTimeoutCalledOnce returns true if FakeContext.WithTimeout was called exactly once
func (f *FakeContext) WithTimeoutCalledOnce() bool {
	return len(f.WithTimeoutCalls) == 1
}

// AssertWithTimeoutCalledOnce calls t.Error if FakeContext.WithTimeout was not called exactly once
func (f *FakeContext) AssertWithTimeoutCalledOnce(t *testing.T) {
	t.Helper()
	if len(f.WithTimeoutCalls) != 1 {
		t.Errorf("FakeContext.WithTimeout called %d times, expected 1", len(f.WithTimeoutCalls))
	}
}

// WithTimeoutCalledN returns true if FakeContext.WithTimeout was called at least n times
func (f *FakeContext) WithTimeoutCalledN(n int) bool {
	return len(f.WithTimeoutCalls) >= n
}

// AssertWithTimeoutCalledN calls t.Error if FakeContext.WithTimeout was called less than n times
func (f *FakeContext) AssertWithTimeoutCalledN(t *testing.T, n int) {
	t.Helper()
	if len(f.WithTimeoutCalls) < n {
		t.Errorf("FakeContext.WithTimeout called %d times, expected >= %d", len(f.WithTimeoutCalls), n)
	}
}

// WithTimeoutCalledWith returns true if FakeContext.WithTimeout was called with the given values
func (_f37 *FakeContext) WithTimeoutCalledWith(timeout time.Duration) (found bool) {
	for _, call := range _f37.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Timeout, timeout) {
			found = true
			break
		}
	}

	return
}

// AssertWithTimeoutCalledWith calls t.Error if FakeContext.WithTimeout was not called with the given values
func (_f38 *FakeContext) AssertWithTimeoutCalledWith(t *testing.T, timeout time.Duration) {
	t.Helper()
	var found bool
	for _, call := range _f38.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Timeout, timeout) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithTimeout not called with expected parameters")
	}
}

// WithTimeoutCalledOnceWith returns true if FakeContext.WithTimeout was called exactly once with the given values
func (_f39 *FakeContext) WithTimeoutCalledOnceWith(timeout time.Duration) bool {
	var count int
	for _, call := range _f39.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Timeout, timeout) {
			count++
		}
	}

	return count == 1
}

// AssertWithTimeoutCalledOnceWith calls t.Error if FakeContext.WithTimeout was not called exactly once with the given values
func (_f40 *FakeContext) AssertWithTimeoutCalledOnceWith(t *testing.T, timeout time.Duration) {
	t.Helper()
	var count int
	for _, call := range _f40.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Timeout, timeout) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithTimeout called %d times with expected parameters, expected one", count)
	}
}

// WithTimeoutResultsForCall returns the result values for the first call to FakeContext.WithTimeout with the given values
func (_f41 *FakeContext) WithTimeoutResultsForCall(timeout time.Duration) (ident1 Context, ident2 context.CancelFunc, found bool) {
	for _, call := range _f41.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Timeout, timeout) {
			ident1 = call.Results.Ident1
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}
