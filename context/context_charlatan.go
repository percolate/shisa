// generated by "charlatan -output=./context_charlatan.go Context".  DO NOT EDIT.

package context

import "context"
import "time"
import "github.com/opentracing/opentracing-go"
import "github.com/percolate/shisa/models"
import "reflect"

// ContextDeadlineInvocation represents a single call of FakeContext.Deadline
type ContextDeadlineInvocation struct {
	Results struct {
		Deadline time.Time
		Ok       bool
	}
}

// ContextDoneInvocation represents a single call of FakeContext.Done
type ContextDoneInvocation struct {
	Results struct {
		Ident1 <-chan struct{}
	}
}

// ContextErrInvocation represents a single call of FakeContext.Err
type ContextErrInvocation struct {
	Results struct {
		Ident2 error
	}
}

// ContextValueInvocation represents a single call of FakeContext.Value
type ContextValueInvocation struct {
	Parameters struct {
		Key interface{}
	}
	Results struct {
		Ident3 interface{}
	}
}

// ContextRequestIDInvocation represents a single call of FakeContext.RequestID
type ContextRequestIDInvocation struct {
	Results struct {
		Ident1 string
	}
}

// ContextActorInvocation represents a single call of FakeContext.Actor
type ContextActorInvocation struct {
	Results struct {
		Ident1 models.User
	}
}

// ContextSpanInvocation represents a single call of FakeContext.Span
type ContextSpanInvocation struct {
	Results struct {
		Ident1 opentracing.Span
	}
}

// ContextStartSpanInvocation represents a single call of FakeContext.StartSpan
type ContextStartSpanInvocation struct {
	Parameters struct {
		Ident1 string
		Ident2 []opentracing.StartSpanOption
	}
	Results struct {
		Ident3 opentracing.Span
	}
}

// ContextWithParentInvocation represents a single call of FakeContext.WithParent
type ContextWithParentInvocation struct {
	Parameters struct {
		Ident1 context.Context
	}
	Results struct {
		Ident2 Context
	}
}

// ContextWithActorInvocation represents a single call of FakeContext.WithActor
type ContextWithActorInvocation struct {
	Parameters struct {
		Ident1 models.User
	}
	Results struct {
		Ident2 Context
	}
}

// ContextWithRequestIDInvocation represents a single call of FakeContext.WithRequestID
type ContextWithRequestIDInvocation struct {
	Parameters struct {
		Ident1 string
	}
	Results struct {
		Ident2 Context
	}
}

// ContextWithSpanInvocation represents a single call of FakeContext.WithSpan
type ContextWithSpanInvocation struct {
	Parameters struct {
		Ident1 opentracing.Span
	}
	Results struct {
		Ident2 Context
	}
}

// ContextWithValueInvocation represents a single call of FakeContext.WithValue
type ContextWithValueInvocation struct {
	Parameters struct {
		Key   interface{}
		Value interface{}
	}
	Results struct {
		Ident1 Context
	}
}

// ContextWithCancelInvocation represents a single call of FakeContext.WithCancel
type ContextWithCancelInvocation struct {
	Results struct {
		Ident1 Context
		Ident2 context.CancelFunc
	}
}

// ContextWithDeadlineInvocation represents a single call of FakeContext.WithDeadline
type ContextWithDeadlineInvocation struct {
	Parameters struct {
		Ident1 time.Time
	}
	Results struct {
		Ident2 Context
		Ident3 context.CancelFunc
	}
}

// ContextWithTimeoutInvocation represents a single call of FakeContext.WithTimeout
type ContextWithTimeoutInvocation struct {
	Parameters struct {
		Ident1 time.Duration
	}
	Results struct {
		Ident2 Context
		Ident3 context.CancelFunc
	}
}

// ContextTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type ContextTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeContext is a mock implementation of Context for testing.
Use it in your tests as in this example:

	package example

	func TestWithContext(t *testing.T) {
		f := &context.FakeContext{
			DeadlineHook: func() (deadline time.Time, ok bool) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeDeadline ...
		f.AssertDeadlineCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeDeadline.
*/
type FakeContext struct {
	DeadlineHook      func() (time.Time, bool)
	DoneHook          func() <-chan struct{}
	ErrHook           func() error
	ValueHook         func(interface{}) interface{}
	RequestIDHook     func() string
	ActorHook         func() models.User
	SpanHook          func() opentracing.Span
	StartSpanHook     func(string, ...opentracing.StartSpanOption) opentracing.Span
	WithParentHook    func(context.Context) Context
	WithActorHook     func(models.User) Context
	WithRequestIDHook func(string) Context
	WithSpanHook      func(opentracing.Span) Context
	WithValueHook     func(interface{}, interface{}) Context
	WithCancelHook    func() (Context, context.CancelFunc)
	WithDeadlineHook  func(time.Time) (Context, context.CancelFunc)
	WithTimeoutHook   func(time.Duration) (Context, context.CancelFunc)

	DeadlineCalls      []*ContextDeadlineInvocation
	DoneCalls          []*ContextDoneInvocation
	ErrCalls           []*ContextErrInvocation
	ValueCalls         []*ContextValueInvocation
	RequestIDCalls     []*ContextRequestIDInvocation
	ActorCalls         []*ContextActorInvocation
	SpanCalls          []*ContextSpanInvocation
	StartSpanCalls     []*ContextStartSpanInvocation
	WithParentCalls    []*ContextWithParentInvocation
	WithActorCalls     []*ContextWithActorInvocation
	WithRequestIDCalls []*ContextWithRequestIDInvocation
	WithSpanCalls      []*ContextWithSpanInvocation
	WithValueCalls     []*ContextWithValueInvocation
	WithCancelCalls    []*ContextWithCancelInvocation
	WithDeadlineCalls  []*ContextWithDeadlineInvocation
	WithTimeoutCalls   []*ContextWithTimeoutInvocation
}

// NewFakeContextDefaultPanic returns an instance of FakeContext with all hooks configured to panic
func NewFakeContextDefaultPanic() *FakeContext {
	return &FakeContext{
		DeadlineHook: func() (deadline time.Time, ok bool) {
			panic("Unexpected call to Context.Deadline")
		},
		DoneHook: func() (ident1 <-chan struct{}) {
			panic("Unexpected call to Context.Done")
		},
		ErrHook: func() (ident2 error) {
			panic("Unexpected call to Context.Err")
		},
		ValueHook: func(interface{}) (ident3 interface{}) {
			panic("Unexpected call to Context.Value")
		},
		RequestIDHook: func() (ident1 string) {
			panic("Unexpected call to Context.RequestID")
		},
		ActorHook: func() (ident1 models.User) {
			panic("Unexpected call to Context.Actor")
		},
		SpanHook: func() (ident1 opentracing.Span) {
			panic("Unexpected call to Context.Span")
		},
		StartSpanHook: func(string, ...opentracing.StartSpanOption) (ident3 opentracing.Span) {
			panic("Unexpected call to Context.StartSpan")
		},
		WithParentHook: func(context.Context) (ident2 Context) {
			panic("Unexpected call to Context.WithParent")
		},
		WithActorHook: func(models.User) (ident2 Context) {
			panic("Unexpected call to Context.WithActor")
		},
		WithRequestIDHook: func(string) (ident2 Context) {
			panic("Unexpected call to Context.WithRequestID")
		},
		WithSpanHook: func(opentracing.Span) (ident2 Context) {
			panic("Unexpected call to Context.WithSpan")
		},
		WithValueHook: func(interface{}, interface{}) (ident1 Context) {
			panic("Unexpected call to Context.WithValue")
		},
		WithCancelHook: func() (ident1 Context, ident2 context.CancelFunc) {
			panic("Unexpected call to Context.WithCancel")
		},
		WithDeadlineHook: func(time.Time) (ident2 Context, ident3 context.CancelFunc) {
			panic("Unexpected call to Context.WithDeadline")
		},
		WithTimeoutHook: func(time.Duration) (ident2 Context, ident3 context.CancelFunc) {
			panic("Unexpected call to Context.WithTimeout")
		},
	}
}

// NewFakeContextDefaultFatal returns an instance of FakeContext with all hooks configured to call t.Fatal
func NewFakeContextDefaultFatal(t ContextTestingT) *FakeContext {
	return &FakeContext{
		DeadlineHook: func() (deadline time.Time, ok bool) {
			t.Fatal("Unexpected call to Context.Deadline")
			return
		},
		DoneHook: func() (ident1 <-chan struct{}) {
			t.Fatal("Unexpected call to Context.Done")
			return
		},
		ErrHook: func() (ident2 error) {
			t.Fatal("Unexpected call to Context.Err")
			return
		},
		ValueHook: func(interface{}) (ident3 interface{}) {
			t.Fatal("Unexpected call to Context.Value")
			return
		},
		RequestIDHook: func() (ident1 string) {
			t.Fatal("Unexpected call to Context.RequestID")
			return
		},
		ActorHook: func() (ident1 models.User) {
			t.Fatal("Unexpected call to Context.Actor")
			return
		},
		SpanHook: func() (ident1 opentracing.Span) {
			t.Fatal("Unexpected call to Context.Span")
			return
		},
		StartSpanHook: func(string, ...opentracing.StartSpanOption) (ident3 opentracing.Span) {
			t.Fatal("Unexpected call to Context.StartSpan")
			return
		},
		WithParentHook: func(context.Context) (ident2 Context) {
			t.Fatal("Unexpected call to Context.WithParent")
			return
		},
		WithActorHook: func(models.User) (ident2 Context) {
			t.Fatal("Unexpected call to Context.WithActor")
			return
		},
		WithRequestIDHook: func(string) (ident2 Context) {
			t.Fatal("Unexpected call to Context.WithRequestID")
			return
		},
		WithSpanHook: func(opentracing.Span) (ident2 Context) {
			t.Fatal("Unexpected call to Context.WithSpan")
			return
		},
		WithValueHook: func(interface{}, interface{}) (ident1 Context) {
			t.Fatal("Unexpected call to Context.WithValue")
			return
		},
		WithCancelHook: func() (ident1 Context, ident2 context.CancelFunc) {
			t.Fatal("Unexpected call to Context.WithCancel")
			return
		},
		WithDeadlineHook: func(time.Time) (ident2 Context, ident3 context.CancelFunc) {
			t.Fatal("Unexpected call to Context.WithDeadline")
			return
		},
		WithTimeoutHook: func(time.Duration) (ident2 Context, ident3 context.CancelFunc) {
			t.Fatal("Unexpected call to Context.WithTimeout")
			return
		},
	}
}

// NewFakeContextDefaultError returns an instance of FakeContext with all hooks configured to call t.Error
func NewFakeContextDefaultError(t ContextTestingT) *FakeContext {
	return &FakeContext{
		DeadlineHook: func() (deadline time.Time, ok bool) {
			t.Error("Unexpected call to Context.Deadline")
			return
		},
		DoneHook: func() (ident1 <-chan struct{}) {
			t.Error("Unexpected call to Context.Done")
			return
		},
		ErrHook: func() (ident2 error) {
			t.Error("Unexpected call to Context.Err")
			return
		},
		ValueHook: func(interface{}) (ident3 interface{}) {
			t.Error("Unexpected call to Context.Value")
			return
		},
		RequestIDHook: func() (ident1 string) {
			t.Error("Unexpected call to Context.RequestID")
			return
		},
		ActorHook: func() (ident1 models.User) {
			t.Error("Unexpected call to Context.Actor")
			return
		},
		SpanHook: func() (ident1 opentracing.Span) {
			t.Error("Unexpected call to Context.Span")
			return
		},
		StartSpanHook: func(string, ...opentracing.StartSpanOption) (ident3 opentracing.Span) {
			t.Error("Unexpected call to Context.StartSpan")
			return
		},
		WithParentHook: func(context.Context) (ident2 Context) {
			t.Error("Unexpected call to Context.WithParent")
			return
		},
		WithActorHook: func(models.User) (ident2 Context) {
			t.Error("Unexpected call to Context.WithActor")
			return
		},
		WithRequestIDHook: func(string) (ident2 Context) {
			t.Error("Unexpected call to Context.WithRequestID")
			return
		},
		WithSpanHook: func(opentracing.Span) (ident2 Context) {
			t.Error("Unexpected call to Context.WithSpan")
			return
		},
		WithValueHook: func(interface{}, interface{}) (ident1 Context) {
			t.Error("Unexpected call to Context.WithValue")
			return
		},
		WithCancelHook: func() (ident1 Context, ident2 context.CancelFunc) {
			t.Error("Unexpected call to Context.WithCancel")
			return
		},
		WithDeadlineHook: func(time.Time) (ident2 Context, ident3 context.CancelFunc) {
			t.Error("Unexpected call to Context.WithDeadline")
			return
		},
		WithTimeoutHook: func(time.Duration) (ident2 Context, ident3 context.CancelFunc) {
			t.Error("Unexpected call to Context.WithTimeout")
			return
		},
	}
}

func (f *FakeContext) Reset() {
	f.DeadlineCalls = []*ContextDeadlineInvocation{}
	f.DoneCalls = []*ContextDoneInvocation{}
	f.ErrCalls = []*ContextErrInvocation{}
	f.ValueCalls = []*ContextValueInvocation{}
	f.RequestIDCalls = []*ContextRequestIDInvocation{}
	f.ActorCalls = []*ContextActorInvocation{}
	f.SpanCalls = []*ContextSpanInvocation{}
	f.StartSpanCalls = []*ContextStartSpanInvocation{}
	f.WithParentCalls = []*ContextWithParentInvocation{}
	f.WithActorCalls = []*ContextWithActorInvocation{}
	f.WithRequestIDCalls = []*ContextWithRequestIDInvocation{}
	f.WithSpanCalls = []*ContextWithSpanInvocation{}
	f.WithValueCalls = []*ContextWithValueInvocation{}
	f.WithCancelCalls = []*ContextWithCancelInvocation{}
	f.WithDeadlineCalls = []*ContextWithDeadlineInvocation{}
	f.WithTimeoutCalls = []*ContextWithTimeoutInvocation{}
}

func (_f1 *FakeContext) Deadline() (deadline time.Time, ok bool) {
	if _f1.DeadlineHook == nil {
		panic("Context.Deadline() called but FakeContext.DeadlineHook is nil")
	}

	invocation := new(ContextDeadlineInvocation)
	_f1.DeadlineCalls = append(_f1.DeadlineCalls, invocation)

	deadline, ok = _f1.DeadlineHook()

	invocation.Results.Deadline = deadline
	invocation.Results.Ok = ok

	return
}

// DeadlineCalled returns true if FakeContext.Deadline was called
func (f *FakeContext) DeadlineCalled() bool {
	return len(f.DeadlineCalls) != 0
}

// AssertDeadlineCalled calls t.Error if FakeContext.Deadline was not called
func (f *FakeContext) AssertDeadlineCalled(t ContextTestingT) {
	t.Helper()
	if len(f.DeadlineCalls) == 0 {
		t.Error("FakeContext.Deadline not called, expected at least one")
	}
}

// DeadlineNotCalled returns true if FakeContext.Deadline was not called
func (f *FakeContext) DeadlineNotCalled() bool {
	return len(f.DeadlineCalls) == 0
}

// AssertDeadlineNotCalled calls t.Error if FakeContext.Deadline was called
func (f *FakeContext) AssertDeadlineNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.DeadlineCalls) != 0 {
		t.Error("FakeContext.Deadline called, expected none")
	}
}

// DeadlineCalledOnce returns true if FakeContext.Deadline was called exactly once
func (f *FakeContext) DeadlineCalledOnce() bool {
	return len(f.DeadlineCalls) == 1
}

// AssertDeadlineCalledOnce calls t.Error if FakeContext.Deadline was not called exactly once
func (f *FakeContext) AssertDeadlineCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.DeadlineCalls) != 1 {
		t.Errorf("FakeContext.Deadline called %d times, expected 1", len(f.DeadlineCalls))
	}
}

// DeadlineCalledN returns true if FakeContext.Deadline was called at least n times
func (f *FakeContext) DeadlineCalledN(n int) bool {
	return len(f.DeadlineCalls) >= n
}

// AssertDeadlineCalledN calls t.Error if FakeContext.Deadline was called less than n times
func (f *FakeContext) AssertDeadlineCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.DeadlineCalls) < n {
		t.Errorf("FakeContext.Deadline called %d times, expected >= %d", len(f.DeadlineCalls), n)
	}
}

func (_f2 *FakeContext) Done() (ident1 <-chan struct{}) {
	if _f2.DoneHook == nil {
		panic("Context.Done() called but FakeContext.DoneHook is nil")
	}

	invocation := new(ContextDoneInvocation)
	_f2.DoneCalls = append(_f2.DoneCalls, invocation)

	ident1 = _f2.DoneHook()

	invocation.Results.Ident1 = ident1

	return
}

// DoneCalled returns true if FakeContext.Done was called
func (f *FakeContext) DoneCalled() bool {
	return len(f.DoneCalls) != 0
}

// AssertDoneCalled calls t.Error if FakeContext.Done was not called
func (f *FakeContext) AssertDoneCalled(t ContextTestingT) {
	t.Helper()
	if len(f.DoneCalls) == 0 {
		t.Error("FakeContext.Done not called, expected at least one")
	}
}

// DoneNotCalled returns true if FakeContext.Done was not called
func (f *FakeContext) DoneNotCalled() bool {
	return len(f.DoneCalls) == 0
}

// AssertDoneNotCalled calls t.Error if FakeContext.Done was called
func (f *FakeContext) AssertDoneNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.DoneCalls) != 0 {
		t.Error("FakeContext.Done called, expected none")
	}
}

// DoneCalledOnce returns true if FakeContext.Done was called exactly once
func (f *FakeContext) DoneCalledOnce() bool {
	return len(f.DoneCalls) == 1
}

// AssertDoneCalledOnce calls t.Error if FakeContext.Done was not called exactly once
func (f *FakeContext) AssertDoneCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.DoneCalls) != 1 {
		t.Errorf("FakeContext.Done called %d times, expected 1", len(f.DoneCalls))
	}
}

// DoneCalledN returns true if FakeContext.Done was called at least n times
func (f *FakeContext) DoneCalledN(n int) bool {
	return len(f.DoneCalls) >= n
}

// AssertDoneCalledN calls t.Error if FakeContext.Done was called less than n times
func (f *FakeContext) AssertDoneCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.DoneCalls) < n {
		t.Errorf("FakeContext.Done called %d times, expected >= %d", len(f.DoneCalls), n)
	}
}

func (_f3 *FakeContext) Err() (ident2 error) {
	if _f3.ErrHook == nil {
		panic("Context.Err() called but FakeContext.ErrHook is nil")
	}

	invocation := new(ContextErrInvocation)
	_f3.ErrCalls = append(_f3.ErrCalls, invocation)

	ident2 = _f3.ErrHook()

	invocation.Results.Ident2 = ident2

	return
}

// ErrCalled returns true if FakeContext.Err was called
func (f *FakeContext) ErrCalled() bool {
	return len(f.ErrCalls) != 0
}

// AssertErrCalled calls t.Error if FakeContext.Err was not called
func (f *FakeContext) AssertErrCalled(t ContextTestingT) {
	t.Helper()
	if len(f.ErrCalls) == 0 {
		t.Error("FakeContext.Err not called, expected at least one")
	}
}

// ErrNotCalled returns true if FakeContext.Err was not called
func (f *FakeContext) ErrNotCalled() bool {
	return len(f.ErrCalls) == 0
}

// AssertErrNotCalled calls t.Error if FakeContext.Err was called
func (f *FakeContext) AssertErrNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.ErrCalls) != 0 {
		t.Error("FakeContext.Err called, expected none")
	}
}

// ErrCalledOnce returns true if FakeContext.Err was called exactly once
func (f *FakeContext) ErrCalledOnce() bool {
	return len(f.ErrCalls) == 1
}

// AssertErrCalledOnce calls t.Error if FakeContext.Err was not called exactly once
func (f *FakeContext) AssertErrCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.ErrCalls) != 1 {
		t.Errorf("FakeContext.Err called %d times, expected 1", len(f.ErrCalls))
	}
}

// ErrCalledN returns true if FakeContext.Err was called at least n times
func (f *FakeContext) ErrCalledN(n int) bool {
	return len(f.ErrCalls) >= n
}

// AssertErrCalledN calls t.Error if FakeContext.Err was called less than n times
func (f *FakeContext) AssertErrCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.ErrCalls) < n {
		t.Errorf("FakeContext.Err called %d times, expected >= %d", len(f.ErrCalls), n)
	}
}

func (_f4 *FakeContext) Value(key interface{}) (ident3 interface{}) {
	if _f4.ValueHook == nil {
		panic("Context.Value() called but FakeContext.ValueHook is nil")
	}

	invocation := new(ContextValueInvocation)
	_f4.ValueCalls = append(_f4.ValueCalls, invocation)

	invocation.Parameters.Key = key

	ident3 = _f4.ValueHook(key)

	invocation.Results.Ident3 = ident3

	return
}

// ValueCalled returns true if FakeContext.Value was called
func (f *FakeContext) ValueCalled() bool {
	return len(f.ValueCalls) != 0
}

// AssertValueCalled calls t.Error if FakeContext.Value was not called
func (f *FakeContext) AssertValueCalled(t ContextTestingT) {
	t.Helper()
	if len(f.ValueCalls) == 0 {
		t.Error("FakeContext.Value not called, expected at least one")
	}
}

// ValueNotCalled returns true if FakeContext.Value was not called
func (f *FakeContext) ValueNotCalled() bool {
	return len(f.ValueCalls) == 0
}

// AssertValueNotCalled calls t.Error if FakeContext.Value was called
func (f *FakeContext) AssertValueNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.ValueCalls) != 0 {
		t.Error("FakeContext.Value called, expected none")
	}
}

// ValueCalledOnce returns true if FakeContext.Value was called exactly once
func (f *FakeContext) ValueCalledOnce() bool {
	return len(f.ValueCalls) == 1
}

// AssertValueCalledOnce calls t.Error if FakeContext.Value was not called exactly once
func (f *FakeContext) AssertValueCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.ValueCalls) != 1 {
		t.Errorf("FakeContext.Value called %d times, expected 1", len(f.ValueCalls))
	}
}

// ValueCalledN returns true if FakeContext.Value was called at least n times
func (f *FakeContext) ValueCalledN(n int) bool {
	return len(f.ValueCalls) >= n
}

// AssertValueCalledN calls t.Error if FakeContext.Value was called less than n times
func (f *FakeContext) AssertValueCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.ValueCalls) < n {
		t.Errorf("FakeContext.Value called %d times, expected >= %d", len(f.ValueCalls), n)
	}
}

// ValueCalledWith returns true if FakeContext.Value was called with the given values
func (_f5 *FakeContext) ValueCalledWith(key interface{}) (found bool) {
	for _, call := range _f5.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			found = true
			break
		}
	}

	return
}

// AssertValueCalledWith calls t.Error if FakeContext.Value was not called with the given values
func (_f6 *FakeContext) AssertValueCalledWith(t ContextTestingT, key interface{}) {
	t.Helper()
	var found bool
	for _, call := range _f6.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.Value not called with expected parameters")
	}
}

// ValueCalledOnceWith returns true if FakeContext.Value was called exactly once with the given values
func (_f7 *FakeContext) ValueCalledOnceWith(key interface{}) bool {
	var count int
	for _, call := range _f7.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			count++
		}
	}

	return count == 1
}

// AssertValueCalledOnceWith calls t.Error if FakeContext.Value was not called exactly once with the given values
func (_f8 *FakeContext) AssertValueCalledOnceWith(t ContextTestingT, key interface{}) {
	t.Helper()
	var count int
	for _, call := range _f8.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.Value called %d times with expected parameters, expected one", count)
	}
}

// ValueResultsForCall returns the result values for the first call to FakeContext.Value with the given values
func (_f9 *FakeContext) ValueResultsForCall(key interface{}) (ident3 interface{}, found bool) {
	for _, call := range _f9.ValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) {
			ident3 = call.Results.Ident3
			found = true
			break
		}
	}

	return
}

func (_f10 *FakeContext) RequestID() (ident1 string) {
	if _f10.RequestIDHook == nil {
		panic("Context.RequestID() called but FakeContext.RequestIDHook is nil")
	}

	invocation := new(ContextRequestIDInvocation)
	_f10.RequestIDCalls = append(_f10.RequestIDCalls, invocation)

	ident1 = _f10.RequestIDHook()

	invocation.Results.Ident1 = ident1

	return
}

// RequestIDCalled returns true if FakeContext.RequestID was called
func (f *FakeContext) RequestIDCalled() bool {
	return len(f.RequestIDCalls) != 0
}

// AssertRequestIDCalled calls t.Error if FakeContext.RequestID was not called
func (f *FakeContext) AssertRequestIDCalled(t ContextTestingT) {
	t.Helper()
	if len(f.RequestIDCalls) == 0 {
		t.Error("FakeContext.RequestID not called, expected at least one")
	}
}

// RequestIDNotCalled returns true if FakeContext.RequestID was not called
func (f *FakeContext) RequestIDNotCalled() bool {
	return len(f.RequestIDCalls) == 0
}

// AssertRequestIDNotCalled calls t.Error if FakeContext.RequestID was called
func (f *FakeContext) AssertRequestIDNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.RequestIDCalls) != 0 {
		t.Error("FakeContext.RequestID called, expected none")
	}
}

// RequestIDCalledOnce returns true if FakeContext.RequestID was called exactly once
func (f *FakeContext) RequestIDCalledOnce() bool {
	return len(f.RequestIDCalls) == 1
}

// AssertRequestIDCalledOnce calls t.Error if FakeContext.RequestID was not called exactly once
func (f *FakeContext) AssertRequestIDCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.RequestIDCalls) != 1 {
		t.Errorf("FakeContext.RequestID called %d times, expected 1", len(f.RequestIDCalls))
	}
}

// RequestIDCalledN returns true if FakeContext.RequestID was called at least n times
func (f *FakeContext) RequestIDCalledN(n int) bool {
	return len(f.RequestIDCalls) >= n
}

// AssertRequestIDCalledN calls t.Error if FakeContext.RequestID was called less than n times
func (f *FakeContext) AssertRequestIDCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.RequestIDCalls) < n {
		t.Errorf("FakeContext.RequestID called %d times, expected >= %d", len(f.RequestIDCalls), n)
	}
}

func (_f11 *FakeContext) Actor() (ident1 models.User) {
	if _f11.ActorHook == nil {
		panic("Context.Actor() called but FakeContext.ActorHook is nil")
	}

	invocation := new(ContextActorInvocation)
	_f11.ActorCalls = append(_f11.ActorCalls, invocation)

	ident1 = _f11.ActorHook()

	invocation.Results.Ident1 = ident1

	return
}

// ActorCalled returns true if FakeContext.Actor was called
func (f *FakeContext) ActorCalled() bool {
	return len(f.ActorCalls) != 0
}

// AssertActorCalled calls t.Error if FakeContext.Actor was not called
func (f *FakeContext) AssertActorCalled(t ContextTestingT) {
	t.Helper()
	if len(f.ActorCalls) == 0 {
		t.Error("FakeContext.Actor not called, expected at least one")
	}
}

// ActorNotCalled returns true if FakeContext.Actor was not called
func (f *FakeContext) ActorNotCalled() bool {
	return len(f.ActorCalls) == 0
}

// AssertActorNotCalled calls t.Error if FakeContext.Actor was called
func (f *FakeContext) AssertActorNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.ActorCalls) != 0 {
		t.Error("FakeContext.Actor called, expected none")
	}
}

// ActorCalledOnce returns true if FakeContext.Actor was called exactly once
func (f *FakeContext) ActorCalledOnce() bool {
	return len(f.ActorCalls) == 1
}

// AssertActorCalledOnce calls t.Error if FakeContext.Actor was not called exactly once
func (f *FakeContext) AssertActorCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.ActorCalls) != 1 {
		t.Errorf("FakeContext.Actor called %d times, expected 1", len(f.ActorCalls))
	}
}

// ActorCalledN returns true if FakeContext.Actor was called at least n times
func (f *FakeContext) ActorCalledN(n int) bool {
	return len(f.ActorCalls) >= n
}

// AssertActorCalledN calls t.Error if FakeContext.Actor was called less than n times
func (f *FakeContext) AssertActorCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.ActorCalls) < n {
		t.Errorf("FakeContext.Actor called %d times, expected >= %d", len(f.ActorCalls), n)
	}
}

func (_f12 *FakeContext) Span() (ident1 opentracing.Span) {
	if _f12.SpanHook == nil {
		panic("Context.Span() called but FakeContext.SpanHook is nil")
	}

	invocation := new(ContextSpanInvocation)
	_f12.SpanCalls = append(_f12.SpanCalls, invocation)

	ident1 = _f12.SpanHook()

	invocation.Results.Ident1 = ident1

	return
}

// SpanCalled returns true if FakeContext.Span was called
func (f *FakeContext) SpanCalled() bool {
	return len(f.SpanCalls) != 0
}

// AssertSpanCalled calls t.Error if FakeContext.Span was not called
func (f *FakeContext) AssertSpanCalled(t ContextTestingT) {
	t.Helper()
	if len(f.SpanCalls) == 0 {
		t.Error("FakeContext.Span not called, expected at least one")
	}
}

// SpanNotCalled returns true if FakeContext.Span was not called
func (f *FakeContext) SpanNotCalled() bool {
	return len(f.SpanCalls) == 0
}

// AssertSpanNotCalled calls t.Error if FakeContext.Span was called
func (f *FakeContext) AssertSpanNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.SpanCalls) != 0 {
		t.Error("FakeContext.Span called, expected none")
	}
}

// SpanCalledOnce returns true if FakeContext.Span was called exactly once
func (f *FakeContext) SpanCalledOnce() bool {
	return len(f.SpanCalls) == 1
}

// AssertSpanCalledOnce calls t.Error if FakeContext.Span was not called exactly once
func (f *FakeContext) AssertSpanCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.SpanCalls) != 1 {
		t.Errorf("FakeContext.Span called %d times, expected 1", len(f.SpanCalls))
	}
}

// SpanCalledN returns true if FakeContext.Span was called at least n times
func (f *FakeContext) SpanCalledN(n int) bool {
	return len(f.SpanCalls) >= n
}

// AssertSpanCalledN calls t.Error if FakeContext.Span was called less than n times
func (f *FakeContext) AssertSpanCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.SpanCalls) < n {
		t.Errorf("FakeContext.Span called %d times, expected >= %d", len(f.SpanCalls), n)
	}
}

func (_f13 *FakeContext) StartSpan(ident1 string, ident2 ...opentracing.StartSpanOption) (ident3 opentracing.Span) {
	if _f13.StartSpanHook == nil {
		panic("Context.StartSpan() called but FakeContext.StartSpanHook is nil")
	}

	invocation := new(ContextStartSpanInvocation)
	_f13.StartSpanCalls = append(_f13.StartSpanCalls, invocation)

	invocation.Parameters.Ident1 = ident1
	invocation.Parameters.Ident2 = ident2

	ident3 = _f13.StartSpanHook(ident1, ident2...)

	invocation.Results.Ident3 = ident3

	return
}

// StartSpanCalled returns true if FakeContext.StartSpan was called
func (f *FakeContext) StartSpanCalled() bool {
	return len(f.StartSpanCalls) != 0
}

// AssertStartSpanCalled calls t.Error if FakeContext.StartSpan was not called
func (f *FakeContext) AssertStartSpanCalled(t ContextTestingT) {
	t.Helper()
	if len(f.StartSpanCalls) == 0 {
		t.Error("FakeContext.StartSpan not called, expected at least one")
	}
}

// StartSpanNotCalled returns true if FakeContext.StartSpan was not called
func (f *FakeContext) StartSpanNotCalled() bool {
	return len(f.StartSpanCalls) == 0
}

// AssertStartSpanNotCalled calls t.Error if FakeContext.StartSpan was called
func (f *FakeContext) AssertStartSpanNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.StartSpanCalls) != 0 {
		t.Error("FakeContext.StartSpan called, expected none")
	}
}

// StartSpanCalledOnce returns true if FakeContext.StartSpan was called exactly once
func (f *FakeContext) StartSpanCalledOnce() bool {
	return len(f.StartSpanCalls) == 1
}

// AssertStartSpanCalledOnce calls t.Error if FakeContext.StartSpan was not called exactly once
func (f *FakeContext) AssertStartSpanCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.StartSpanCalls) != 1 {
		t.Errorf("FakeContext.StartSpan called %d times, expected 1", len(f.StartSpanCalls))
	}
}

// StartSpanCalledN returns true if FakeContext.StartSpan was called at least n times
func (f *FakeContext) StartSpanCalledN(n int) bool {
	return len(f.StartSpanCalls) >= n
}

// AssertStartSpanCalledN calls t.Error if FakeContext.StartSpan was called less than n times
func (f *FakeContext) AssertStartSpanCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.StartSpanCalls) < n {
		t.Errorf("FakeContext.StartSpan called %d times, expected >= %d", len(f.StartSpanCalls), n)
	}
}

// StartSpanCalledWith returns true if FakeContext.StartSpan was called with the given values
func (_f14 *FakeContext) StartSpanCalledWith(ident1 string, ident2 ...opentracing.StartSpanOption) (found bool) {
	for _, call := range _f14.StartSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) && reflect.DeepEqual(call.Parameters.Ident2, ident2) {
			found = true
			break
		}
	}

	return
}

// AssertStartSpanCalledWith calls t.Error if FakeContext.StartSpan was not called with the given values
func (_f15 *FakeContext) AssertStartSpanCalledWith(t ContextTestingT, ident1 string, ident2 ...opentracing.StartSpanOption) {
	t.Helper()
	var found bool
	for _, call := range _f15.StartSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) && reflect.DeepEqual(call.Parameters.Ident2, ident2) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.StartSpan not called with expected parameters")
	}
}

// StartSpanCalledOnceWith returns true if FakeContext.StartSpan was called exactly once with the given values
func (_f16 *FakeContext) StartSpanCalledOnceWith(ident1 string, ident2 ...opentracing.StartSpanOption) bool {
	var count int
	for _, call := range _f16.StartSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) && reflect.DeepEqual(call.Parameters.Ident2, ident2) {
			count++
		}
	}

	return count == 1
}

// AssertStartSpanCalledOnceWith calls t.Error if FakeContext.StartSpan was not called exactly once with the given values
func (_f17 *FakeContext) AssertStartSpanCalledOnceWith(t ContextTestingT, ident1 string, ident2 ...opentracing.StartSpanOption) {
	t.Helper()
	var count int
	for _, call := range _f17.StartSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) && reflect.DeepEqual(call.Parameters.Ident2, ident2) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.StartSpan called %d times with expected parameters, expected one", count)
	}
}

// StartSpanResultsForCall returns the result values for the first call to FakeContext.StartSpan with the given values
func (_f18 *FakeContext) StartSpanResultsForCall(ident1 string, ident2 ...opentracing.StartSpanOption) (ident3 opentracing.Span, found bool) {
	for _, call := range _f18.StartSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) && reflect.DeepEqual(call.Parameters.Ident2, ident2) {
			ident3 = call.Results.Ident3
			found = true
			break
		}
	}

	return
}

func (_f19 *FakeContext) WithParent(ident1 context.Context) (ident2 Context) {
	if _f19.WithParentHook == nil {
		panic("Context.WithParent() called but FakeContext.WithParentHook is nil")
	}

	invocation := new(ContextWithParentInvocation)
	_f19.WithParentCalls = append(_f19.WithParentCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	ident2 = _f19.WithParentHook(ident1)

	invocation.Results.Ident2 = ident2

	return
}

// WithParentCalled returns true if FakeContext.WithParent was called
func (f *FakeContext) WithParentCalled() bool {
	return len(f.WithParentCalls) != 0
}

// AssertWithParentCalled calls t.Error if FakeContext.WithParent was not called
func (f *FakeContext) AssertWithParentCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithParentCalls) == 0 {
		t.Error("FakeContext.WithParent not called, expected at least one")
	}
}

// WithParentNotCalled returns true if FakeContext.WithParent was not called
func (f *FakeContext) WithParentNotCalled() bool {
	return len(f.WithParentCalls) == 0
}

// AssertWithParentNotCalled calls t.Error if FakeContext.WithParent was called
func (f *FakeContext) AssertWithParentNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithParentCalls) != 0 {
		t.Error("FakeContext.WithParent called, expected none")
	}
}

// WithParentCalledOnce returns true if FakeContext.WithParent was called exactly once
func (f *FakeContext) WithParentCalledOnce() bool {
	return len(f.WithParentCalls) == 1
}

// AssertWithParentCalledOnce calls t.Error if FakeContext.WithParent was not called exactly once
func (f *FakeContext) AssertWithParentCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithParentCalls) != 1 {
		t.Errorf("FakeContext.WithParent called %d times, expected 1", len(f.WithParentCalls))
	}
}

// WithParentCalledN returns true if FakeContext.WithParent was called at least n times
func (f *FakeContext) WithParentCalledN(n int) bool {
	return len(f.WithParentCalls) >= n
}

// AssertWithParentCalledN calls t.Error if FakeContext.WithParent was called less than n times
func (f *FakeContext) AssertWithParentCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithParentCalls) < n {
		t.Errorf("FakeContext.WithParent called %d times, expected >= %d", len(f.WithParentCalls), n)
	}
}

// WithParentCalledWith returns true if FakeContext.WithParent was called with the given values
func (_f20 *FakeContext) WithParentCalledWith(ident1 context.Context) (found bool) {
	for _, call := range _f20.WithParentCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertWithParentCalledWith calls t.Error if FakeContext.WithParent was not called with the given values
func (_f21 *FakeContext) AssertWithParentCalledWith(t ContextTestingT, ident1 context.Context) {
	t.Helper()
	var found bool
	for _, call := range _f21.WithParentCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithParent not called with expected parameters")
	}
}

// WithParentCalledOnceWith returns true if FakeContext.WithParent was called exactly once with the given values
func (_f22 *FakeContext) WithParentCalledOnceWith(ident1 context.Context) bool {
	var count int
	for _, call := range _f22.WithParentCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertWithParentCalledOnceWith calls t.Error if FakeContext.WithParent was not called exactly once with the given values
func (_f23 *FakeContext) AssertWithParentCalledOnceWith(t ContextTestingT, ident1 context.Context) {
	t.Helper()
	var count int
	for _, call := range _f23.WithParentCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithParent called %d times with expected parameters, expected one", count)
	}
}

// WithParentResultsForCall returns the result values for the first call to FakeContext.WithParent with the given values
func (_f24 *FakeContext) WithParentResultsForCall(ident1 context.Context) (ident2 Context, found bool) {
	for _, call := range _f24.WithParentCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}

func (_f25 *FakeContext) WithActor(ident1 models.User) (ident2 Context) {
	if _f25.WithActorHook == nil {
		panic("Context.WithActor() called but FakeContext.WithActorHook is nil")
	}

	invocation := new(ContextWithActorInvocation)
	_f25.WithActorCalls = append(_f25.WithActorCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	ident2 = _f25.WithActorHook(ident1)

	invocation.Results.Ident2 = ident2

	return
}

// WithActorCalled returns true if FakeContext.WithActor was called
func (f *FakeContext) WithActorCalled() bool {
	return len(f.WithActorCalls) != 0
}

// AssertWithActorCalled calls t.Error if FakeContext.WithActor was not called
func (f *FakeContext) AssertWithActorCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithActorCalls) == 0 {
		t.Error("FakeContext.WithActor not called, expected at least one")
	}
}

// WithActorNotCalled returns true if FakeContext.WithActor was not called
func (f *FakeContext) WithActorNotCalled() bool {
	return len(f.WithActorCalls) == 0
}

// AssertWithActorNotCalled calls t.Error if FakeContext.WithActor was called
func (f *FakeContext) AssertWithActorNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithActorCalls) != 0 {
		t.Error("FakeContext.WithActor called, expected none")
	}
}

// WithActorCalledOnce returns true if FakeContext.WithActor was called exactly once
func (f *FakeContext) WithActorCalledOnce() bool {
	return len(f.WithActorCalls) == 1
}

// AssertWithActorCalledOnce calls t.Error if FakeContext.WithActor was not called exactly once
func (f *FakeContext) AssertWithActorCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithActorCalls) != 1 {
		t.Errorf("FakeContext.WithActor called %d times, expected 1", len(f.WithActorCalls))
	}
}

// WithActorCalledN returns true if FakeContext.WithActor was called at least n times
func (f *FakeContext) WithActorCalledN(n int) bool {
	return len(f.WithActorCalls) >= n
}

// AssertWithActorCalledN calls t.Error if FakeContext.WithActor was called less than n times
func (f *FakeContext) AssertWithActorCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithActorCalls) < n {
		t.Errorf("FakeContext.WithActor called %d times, expected >= %d", len(f.WithActorCalls), n)
	}
}

// WithActorCalledWith returns true if FakeContext.WithActor was called with the given values
func (_f26 *FakeContext) WithActorCalledWith(ident1 models.User) (found bool) {
	for _, call := range _f26.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertWithActorCalledWith calls t.Error if FakeContext.WithActor was not called with the given values
func (_f27 *FakeContext) AssertWithActorCalledWith(t ContextTestingT, ident1 models.User) {
	t.Helper()
	var found bool
	for _, call := range _f27.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithActor not called with expected parameters")
	}
}

// WithActorCalledOnceWith returns true if FakeContext.WithActor was called exactly once with the given values
func (_f28 *FakeContext) WithActorCalledOnceWith(ident1 models.User) bool {
	var count int
	for _, call := range _f28.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertWithActorCalledOnceWith calls t.Error if FakeContext.WithActor was not called exactly once with the given values
func (_f29 *FakeContext) AssertWithActorCalledOnceWith(t ContextTestingT, ident1 models.User) {
	t.Helper()
	var count int
	for _, call := range _f29.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithActor called %d times with expected parameters, expected one", count)
	}
}

// WithActorResultsForCall returns the result values for the first call to FakeContext.WithActor with the given values
func (_f30 *FakeContext) WithActorResultsForCall(ident1 models.User) (ident2 Context, found bool) {
	for _, call := range _f30.WithActorCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}

func (_f31 *FakeContext) WithRequestID(ident1 string) (ident2 Context) {
	if _f31.WithRequestIDHook == nil {
		panic("Context.WithRequestID() called but FakeContext.WithRequestIDHook is nil")
	}

	invocation := new(ContextWithRequestIDInvocation)
	_f31.WithRequestIDCalls = append(_f31.WithRequestIDCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	ident2 = _f31.WithRequestIDHook(ident1)

	invocation.Results.Ident2 = ident2

	return
}

// WithRequestIDCalled returns true if FakeContext.WithRequestID was called
func (f *FakeContext) WithRequestIDCalled() bool {
	return len(f.WithRequestIDCalls) != 0
}

// AssertWithRequestIDCalled calls t.Error if FakeContext.WithRequestID was not called
func (f *FakeContext) AssertWithRequestIDCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithRequestIDCalls) == 0 {
		t.Error("FakeContext.WithRequestID not called, expected at least one")
	}
}

// WithRequestIDNotCalled returns true if FakeContext.WithRequestID was not called
func (f *FakeContext) WithRequestIDNotCalled() bool {
	return len(f.WithRequestIDCalls) == 0
}

// AssertWithRequestIDNotCalled calls t.Error if FakeContext.WithRequestID was called
func (f *FakeContext) AssertWithRequestIDNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithRequestIDCalls) != 0 {
		t.Error("FakeContext.WithRequestID called, expected none")
	}
}

// WithRequestIDCalledOnce returns true if FakeContext.WithRequestID was called exactly once
func (f *FakeContext) WithRequestIDCalledOnce() bool {
	return len(f.WithRequestIDCalls) == 1
}

// AssertWithRequestIDCalledOnce calls t.Error if FakeContext.WithRequestID was not called exactly once
func (f *FakeContext) AssertWithRequestIDCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithRequestIDCalls) != 1 {
		t.Errorf("FakeContext.WithRequestID called %d times, expected 1", len(f.WithRequestIDCalls))
	}
}

// WithRequestIDCalledN returns true if FakeContext.WithRequestID was called at least n times
func (f *FakeContext) WithRequestIDCalledN(n int) bool {
	return len(f.WithRequestIDCalls) >= n
}

// AssertWithRequestIDCalledN calls t.Error if FakeContext.WithRequestID was called less than n times
func (f *FakeContext) AssertWithRequestIDCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithRequestIDCalls) < n {
		t.Errorf("FakeContext.WithRequestID called %d times, expected >= %d", len(f.WithRequestIDCalls), n)
	}
}

// WithRequestIDCalledWith returns true if FakeContext.WithRequestID was called with the given values
func (_f32 *FakeContext) WithRequestIDCalledWith(ident1 string) (found bool) {
	for _, call := range _f32.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertWithRequestIDCalledWith calls t.Error if FakeContext.WithRequestID was not called with the given values
func (_f33 *FakeContext) AssertWithRequestIDCalledWith(t ContextTestingT, ident1 string) {
	t.Helper()
	var found bool
	for _, call := range _f33.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithRequestID not called with expected parameters")
	}
}

// WithRequestIDCalledOnceWith returns true if FakeContext.WithRequestID was called exactly once with the given values
func (_f34 *FakeContext) WithRequestIDCalledOnceWith(ident1 string) bool {
	var count int
	for _, call := range _f34.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertWithRequestIDCalledOnceWith calls t.Error if FakeContext.WithRequestID was not called exactly once with the given values
func (_f35 *FakeContext) AssertWithRequestIDCalledOnceWith(t ContextTestingT, ident1 string) {
	t.Helper()
	var count int
	for _, call := range _f35.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithRequestID called %d times with expected parameters, expected one", count)
	}
}

// WithRequestIDResultsForCall returns the result values for the first call to FakeContext.WithRequestID with the given values
func (_f36 *FakeContext) WithRequestIDResultsForCall(ident1 string) (ident2 Context, found bool) {
	for _, call := range _f36.WithRequestIDCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}

func (_f37 *FakeContext) WithSpan(ident1 opentracing.Span) (ident2 Context) {
	if _f37.WithSpanHook == nil {
		panic("Context.WithSpan() called but FakeContext.WithSpanHook is nil")
	}

	invocation := new(ContextWithSpanInvocation)
	_f37.WithSpanCalls = append(_f37.WithSpanCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	ident2 = _f37.WithSpanHook(ident1)

	invocation.Results.Ident2 = ident2

	return
}

// WithSpanCalled returns true if FakeContext.WithSpan was called
func (f *FakeContext) WithSpanCalled() bool {
	return len(f.WithSpanCalls) != 0
}

// AssertWithSpanCalled calls t.Error if FakeContext.WithSpan was not called
func (f *FakeContext) AssertWithSpanCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithSpanCalls) == 0 {
		t.Error("FakeContext.WithSpan not called, expected at least one")
	}
}

// WithSpanNotCalled returns true if FakeContext.WithSpan was not called
func (f *FakeContext) WithSpanNotCalled() bool {
	return len(f.WithSpanCalls) == 0
}

// AssertWithSpanNotCalled calls t.Error if FakeContext.WithSpan was called
func (f *FakeContext) AssertWithSpanNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithSpanCalls) != 0 {
		t.Error("FakeContext.WithSpan called, expected none")
	}
}

// WithSpanCalledOnce returns true if FakeContext.WithSpan was called exactly once
func (f *FakeContext) WithSpanCalledOnce() bool {
	return len(f.WithSpanCalls) == 1
}

// AssertWithSpanCalledOnce calls t.Error if FakeContext.WithSpan was not called exactly once
func (f *FakeContext) AssertWithSpanCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithSpanCalls) != 1 {
		t.Errorf("FakeContext.WithSpan called %d times, expected 1", len(f.WithSpanCalls))
	}
}

// WithSpanCalledN returns true if FakeContext.WithSpan was called at least n times
func (f *FakeContext) WithSpanCalledN(n int) bool {
	return len(f.WithSpanCalls) >= n
}

// AssertWithSpanCalledN calls t.Error if FakeContext.WithSpan was called less than n times
func (f *FakeContext) AssertWithSpanCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithSpanCalls) < n {
		t.Errorf("FakeContext.WithSpan called %d times, expected >= %d", len(f.WithSpanCalls), n)
	}
}

// WithSpanCalledWith returns true if FakeContext.WithSpan was called with the given values
func (_f38 *FakeContext) WithSpanCalledWith(ident1 opentracing.Span) (found bool) {
	for _, call := range _f38.WithSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertWithSpanCalledWith calls t.Error if FakeContext.WithSpan was not called with the given values
func (_f39 *FakeContext) AssertWithSpanCalledWith(t ContextTestingT, ident1 opentracing.Span) {
	t.Helper()
	var found bool
	for _, call := range _f39.WithSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithSpan not called with expected parameters")
	}
}

// WithSpanCalledOnceWith returns true if FakeContext.WithSpan was called exactly once with the given values
func (_f40 *FakeContext) WithSpanCalledOnceWith(ident1 opentracing.Span) bool {
	var count int
	for _, call := range _f40.WithSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertWithSpanCalledOnceWith calls t.Error if FakeContext.WithSpan was not called exactly once with the given values
func (_f41 *FakeContext) AssertWithSpanCalledOnceWith(t ContextTestingT, ident1 opentracing.Span) {
	t.Helper()
	var count int
	for _, call := range _f41.WithSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithSpan called %d times with expected parameters, expected one", count)
	}
}

// WithSpanResultsForCall returns the result values for the first call to FakeContext.WithSpan with the given values
func (_f42 *FakeContext) WithSpanResultsForCall(ident1 opentracing.Span) (ident2 Context, found bool) {
	for _, call := range _f42.WithSpanCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			found = true
			break
		}
	}

	return
}

func (_f43 *FakeContext) WithValue(key interface{}, value interface{}) (ident1 Context) {
	if _f43.WithValueHook == nil {
		panic("Context.WithValue() called but FakeContext.WithValueHook is nil")
	}

	invocation := new(ContextWithValueInvocation)
	_f43.WithValueCalls = append(_f43.WithValueCalls, invocation)

	invocation.Parameters.Key = key
	invocation.Parameters.Value = value

	ident1 = _f43.WithValueHook(key, value)

	invocation.Results.Ident1 = ident1

	return
}

// WithValueCalled returns true if FakeContext.WithValue was called
func (f *FakeContext) WithValueCalled() bool {
	return len(f.WithValueCalls) != 0
}

// AssertWithValueCalled calls t.Error if FakeContext.WithValue was not called
func (f *FakeContext) AssertWithValueCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithValueCalls) == 0 {
		t.Error("FakeContext.WithValue not called, expected at least one")
	}
}

// WithValueNotCalled returns true if FakeContext.WithValue was not called
func (f *FakeContext) WithValueNotCalled() bool {
	return len(f.WithValueCalls) == 0
}

// AssertWithValueNotCalled calls t.Error if FakeContext.WithValue was called
func (f *FakeContext) AssertWithValueNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithValueCalls) != 0 {
		t.Error("FakeContext.WithValue called, expected none")
	}
}

// WithValueCalledOnce returns true if FakeContext.WithValue was called exactly once
func (f *FakeContext) WithValueCalledOnce() bool {
	return len(f.WithValueCalls) == 1
}

// AssertWithValueCalledOnce calls t.Error if FakeContext.WithValue was not called exactly once
func (f *FakeContext) AssertWithValueCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithValueCalls) != 1 {
		t.Errorf("FakeContext.WithValue called %d times, expected 1", len(f.WithValueCalls))
	}
}

// WithValueCalledN returns true if FakeContext.WithValue was called at least n times
func (f *FakeContext) WithValueCalledN(n int) bool {
	return len(f.WithValueCalls) >= n
}

// AssertWithValueCalledN calls t.Error if FakeContext.WithValue was called less than n times
func (f *FakeContext) AssertWithValueCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithValueCalls) < n {
		t.Errorf("FakeContext.WithValue called %d times, expected >= %d", len(f.WithValueCalls), n)
	}
}

// WithValueCalledWith returns true if FakeContext.WithValue was called with the given values
func (_f44 *FakeContext) WithValueCalledWith(key interface{}, value interface{}) (found bool) {
	for _, call := range _f44.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			found = true
			break
		}
	}

	return
}

// AssertWithValueCalledWith calls t.Error if FakeContext.WithValue was not called with the given values
func (_f45 *FakeContext) AssertWithValueCalledWith(t ContextTestingT, key interface{}, value interface{}) {
	t.Helper()
	var found bool
	for _, call := range _f45.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithValue not called with expected parameters")
	}
}

// WithValueCalledOnceWith returns true if FakeContext.WithValue was called exactly once with the given values
func (_f46 *FakeContext) WithValueCalledOnceWith(key interface{}, value interface{}) bool {
	var count int
	for _, call := range _f46.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			count++
		}
	}

	return count == 1
}

// AssertWithValueCalledOnceWith calls t.Error if FakeContext.WithValue was not called exactly once with the given values
func (_f47 *FakeContext) AssertWithValueCalledOnceWith(t ContextTestingT, key interface{}, value interface{}) {
	t.Helper()
	var count int
	for _, call := range _f47.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithValue called %d times with expected parameters, expected one", count)
	}
}

// WithValueResultsForCall returns the result values for the first call to FakeContext.WithValue with the given values
func (_f48 *FakeContext) WithValueResultsForCall(key interface{}, value interface{}) (ident1 Context, found bool) {
	for _, call := range _f48.WithValueCalls {
		if reflect.DeepEqual(call.Parameters.Key, key) && reflect.DeepEqual(call.Parameters.Value, value) {
			ident1 = call.Results.Ident1
			found = true
			break
		}
	}

	return
}

func (_f49 *FakeContext) WithCancel() (ident1 Context, ident2 context.CancelFunc) {
	if _f49.WithCancelHook == nil {
		panic("Context.WithCancel() called but FakeContext.WithCancelHook is nil")
	}

	invocation := new(ContextWithCancelInvocation)
	_f49.WithCancelCalls = append(_f49.WithCancelCalls, invocation)

	ident1, ident2 = _f49.WithCancelHook()

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return
}

// WithCancelCalled returns true if FakeContext.WithCancel was called
func (f *FakeContext) WithCancelCalled() bool {
	return len(f.WithCancelCalls) != 0
}

// AssertWithCancelCalled calls t.Error if FakeContext.WithCancel was not called
func (f *FakeContext) AssertWithCancelCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithCancelCalls) == 0 {
		t.Error("FakeContext.WithCancel not called, expected at least one")
	}
}

// WithCancelNotCalled returns true if FakeContext.WithCancel was not called
func (f *FakeContext) WithCancelNotCalled() bool {
	return len(f.WithCancelCalls) == 0
}

// AssertWithCancelNotCalled calls t.Error if FakeContext.WithCancel was called
func (f *FakeContext) AssertWithCancelNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithCancelCalls) != 0 {
		t.Error("FakeContext.WithCancel called, expected none")
	}
}

// WithCancelCalledOnce returns true if FakeContext.WithCancel was called exactly once
func (f *FakeContext) WithCancelCalledOnce() bool {
	return len(f.WithCancelCalls) == 1
}

// AssertWithCancelCalledOnce calls t.Error if FakeContext.WithCancel was not called exactly once
func (f *FakeContext) AssertWithCancelCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithCancelCalls) != 1 {
		t.Errorf("FakeContext.WithCancel called %d times, expected 1", len(f.WithCancelCalls))
	}
}

// WithCancelCalledN returns true if FakeContext.WithCancel was called at least n times
func (f *FakeContext) WithCancelCalledN(n int) bool {
	return len(f.WithCancelCalls) >= n
}

// AssertWithCancelCalledN calls t.Error if FakeContext.WithCancel was called less than n times
func (f *FakeContext) AssertWithCancelCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithCancelCalls) < n {
		t.Errorf("FakeContext.WithCancel called %d times, expected >= %d", len(f.WithCancelCalls), n)
	}
}

func (_f50 *FakeContext) WithDeadline(ident1 time.Time) (ident2 Context, ident3 context.CancelFunc) {
	if _f50.WithDeadlineHook == nil {
		panic("Context.WithDeadline() called but FakeContext.WithDeadlineHook is nil")
	}

	invocation := new(ContextWithDeadlineInvocation)
	_f50.WithDeadlineCalls = append(_f50.WithDeadlineCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	ident2, ident3 = _f50.WithDeadlineHook(ident1)

	invocation.Results.Ident2 = ident2
	invocation.Results.Ident3 = ident3

	return
}

// WithDeadlineCalled returns true if FakeContext.WithDeadline was called
func (f *FakeContext) WithDeadlineCalled() bool {
	return len(f.WithDeadlineCalls) != 0
}

// AssertWithDeadlineCalled calls t.Error if FakeContext.WithDeadline was not called
func (f *FakeContext) AssertWithDeadlineCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithDeadlineCalls) == 0 {
		t.Error("FakeContext.WithDeadline not called, expected at least one")
	}
}

// WithDeadlineNotCalled returns true if FakeContext.WithDeadline was not called
func (f *FakeContext) WithDeadlineNotCalled() bool {
	return len(f.WithDeadlineCalls) == 0
}

// AssertWithDeadlineNotCalled calls t.Error if FakeContext.WithDeadline was called
func (f *FakeContext) AssertWithDeadlineNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithDeadlineCalls) != 0 {
		t.Error("FakeContext.WithDeadline called, expected none")
	}
}

// WithDeadlineCalledOnce returns true if FakeContext.WithDeadline was called exactly once
func (f *FakeContext) WithDeadlineCalledOnce() bool {
	return len(f.WithDeadlineCalls) == 1
}

// AssertWithDeadlineCalledOnce calls t.Error if FakeContext.WithDeadline was not called exactly once
func (f *FakeContext) AssertWithDeadlineCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithDeadlineCalls) != 1 {
		t.Errorf("FakeContext.WithDeadline called %d times, expected 1", len(f.WithDeadlineCalls))
	}
}

// WithDeadlineCalledN returns true if FakeContext.WithDeadline was called at least n times
func (f *FakeContext) WithDeadlineCalledN(n int) bool {
	return len(f.WithDeadlineCalls) >= n
}

// AssertWithDeadlineCalledN calls t.Error if FakeContext.WithDeadline was called less than n times
func (f *FakeContext) AssertWithDeadlineCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithDeadlineCalls) < n {
		t.Errorf("FakeContext.WithDeadline called %d times, expected >= %d", len(f.WithDeadlineCalls), n)
	}
}

// WithDeadlineCalledWith returns true if FakeContext.WithDeadline was called with the given values
func (_f51 *FakeContext) WithDeadlineCalledWith(ident1 time.Time) (found bool) {
	for _, call := range _f51.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertWithDeadlineCalledWith calls t.Error if FakeContext.WithDeadline was not called with the given values
func (_f52 *FakeContext) AssertWithDeadlineCalledWith(t ContextTestingT, ident1 time.Time) {
	t.Helper()
	var found bool
	for _, call := range _f52.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithDeadline not called with expected parameters")
	}
}

// WithDeadlineCalledOnceWith returns true if FakeContext.WithDeadline was called exactly once with the given values
func (_f53 *FakeContext) WithDeadlineCalledOnceWith(ident1 time.Time) bool {
	var count int
	for _, call := range _f53.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertWithDeadlineCalledOnceWith calls t.Error if FakeContext.WithDeadline was not called exactly once with the given values
func (_f54 *FakeContext) AssertWithDeadlineCalledOnceWith(t ContextTestingT, ident1 time.Time) {
	t.Helper()
	var count int
	for _, call := range _f54.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithDeadline called %d times with expected parameters, expected one", count)
	}
}

// WithDeadlineResultsForCall returns the result values for the first call to FakeContext.WithDeadline with the given values
func (_f55 *FakeContext) WithDeadlineResultsForCall(ident1 time.Time) (ident2 Context, ident3 context.CancelFunc, found bool) {
	for _, call := range _f55.WithDeadlineCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			ident3 = call.Results.Ident3
			found = true
			break
		}
	}

	return
}

func (_f56 *FakeContext) WithTimeout(ident1 time.Duration) (ident2 Context, ident3 context.CancelFunc) {
	if _f56.WithTimeoutHook == nil {
		panic("Context.WithTimeout() called but FakeContext.WithTimeoutHook is nil")
	}

	invocation := new(ContextWithTimeoutInvocation)
	_f56.WithTimeoutCalls = append(_f56.WithTimeoutCalls, invocation)

	invocation.Parameters.Ident1 = ident1

	ident2, ident3 = _f56.WithTimeoutHook(ident1)

	invocation.Results.Ident2 = ident2
	invocation.Results.Ident3 = ident3

	return
}

// WithTimeoutCalled returns true if FakeContext.WithTimeout was called
func (f *FakeContext) WithTimeoutCalled() bool {
	return len(f.WithTimeoutCalls) != 0
}

// AssertWithTimeoutCalled calls t.Error if FakeContext.WithTimeout was not called
func (f *FakeContext) AssertWithTimeoutCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithTimeoutCalls) == 0 {
		t.Error("FakeContext.WithTimeout not called, expected at least one")
	}
}

// WithTimeoutNotCalled returns true if FakeContext.WithTimeout was not called
func (f *FakeContext) WithTimeoutNotCalled() bool {
	return len(f.WithTimeoutCalls) == 0
}

// AssertWithTimeoutNotCalled calls t.Error if FakeContext.WithTimeout was called
func (f *FakeContext) AssertWithTimeoutNotCalled(t ContextTestingT) {
	t.Helper()
	if len(f.WithTimeoutCalls) != 0 {
		t.Error("FakeContext.WithTimeout called, expected none")
	}
}

// WithTimeoutCalledOnce returns true if FakeContext.WithTimeout was called exactly once
func (f *FakeContext) WithTimeoutCalledOnce() bool {
	return len(f.WithTimeoutCalls) == 1
}

// AssertWithTimeoutCalledOnce calls t.Error if FakeContext.WithTimeout was not called exactly once
func (f *FakeContext) AssertWithTimeoutCalledOnce(t ContextTestingT) {
	t.Helper()
	if len(f.WithTimeoutCalls) != 1 {
		t.Errorf("FakeContext.WithTimeout called %d times, expected 1", len(f.WithTimeoutCalls))
	}
}

// WithTimeoutCalledN returns true if FakeContext.WithTimeout was called at least n times
func (f *FakeContext) WithTimeoutCalledN(n int) bool {
	return len(f.WithTimeoutCalls) >= n
}

// AssertWithTimeoutCalledN calls t.Error if FakeContext.WithTimeout was called less than n times
func (f *FakeContext) AssertWithTimeoutCalledN(t ContextTestingT, n int) {
	t.Helper()
	if len(f.WithTimeoutCalls) < n {
		t.Errorf("FakeContext.WithTimeout called %d times, expected >= %d", len(f.WithTimeoutCalls), n)
	}
}

// WithTimeoutCalledWith returns true if FakeContext.WithTimeout was called with the given values
func (_f57 *FakeContext) WithTimeoutCalledWith(ident1 time.Duration) (found bool) {
	for _, call := range _f57.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	return
}

// AssertWithTimeoutCalledWith calls t.Error if FakeContext.WithTimeout was not called with the given values
func (_f58 *FakeContext) AssertWithTimeoutCalledWith(t ContextTestingT, ident1 time.Duration) {
	t.Helper()
	var found bool
	for _, call := range _f58.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			found = true
			break
		}
	}

	if !found {
		t.Error("FakeContext.WithTimeout not called with expected parameters")
	}
}

// WithTimeoutCalledOnceWith returns true if FakeContext.WithTimeout was called exactly once with the given values
func (_f59 *FakeContext) WithTimeoutCalledOnceWith(ident1 time.Duration) bool {
	var count int
	for _, call := range _f59.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	return count == 1
}

// AssertWithTimeoutCalledOnceWith calls t.Error if FakeContext.WithTimeout was not called exactly once with the given values
func (_f60 *FakeContext) AssertWithTimeoutCalledOnceWith(t ContextTestingT, ident1 time.Duration) {
	t.Helper()
	var count int
	for _, call := range _f60.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			count++
		}
	}

	if count != 1 {
		t.Errorf("FakeContext.WithTimeout called %d times with expected parameters, expected one", count)
	}
}

// WithTimeoutResultsForCall returns the result values for the first call to FakeContext.WithTimeout with the given values
func (_f61 *FakeContext) WithTimeoutResultsForCall(ident1 time.Duration) (ident2 Context, ident3 context.CancelFunc, found bool) {
	for _, call := range _f61.WithTimeoutCalls {
		if reflect.DeepEqual(call.Parameters.Ident1, ident1) {
			ident2 = call.Results.Ident2
			ident3 = call.Results.Ident3
			found = true
			break
		}
	}

	return
}
